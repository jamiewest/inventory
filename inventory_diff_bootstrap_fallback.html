<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inventory Manager & Change Log (Bootstrap + Offline Fallback)</title>
<!-- Primary Bootstrap CDN -->
<link id="bs-css-1" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Secondary CDNs (will be enabled if primary fails) -->
<link id="bs-css-2" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.3/css/bootstrap.min.css" rel="stylesheet" disabled>
<link id="bs-css-3" href="https://unpkg.com/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" disabled>
<style>
  /* Minimal fallback styling if all CDNs fail */
  :root { color-scheme: light; }
  body { background-color:#f5f7fb; color:#1f2933; }
  .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .table-fixed-head thead th { position: sticky; top: 0; z-index: 2; }
  .scroll-pane { max-height: 60vh; overflow: auto; }
  .menu-spacer { height: 56px; }
  .vis-hide { display: none !important; }
  .fallback .navbar { position:fixed; top:0; left:0; right:0; background:#ffffff; border-bottom:1px solid #d0d7de; padding:.5rem 1rem; }
  .fallback .navbar a { color:#1f2933; text-decoration:none; margin-right:1rem; }
  .fallback .container-fluid, .fallback .container { padding: 0 1rem; }
  .fallback .card { border:1px solid #d0d7de; background:#ffffff; border-radius:.5rem; margin-bottom:1rem; }
  .fallback .card-header, .fallback .card-footer { padding:.75rem 1rem; border-bottom:1px solid #d0d7de; }
  .fallback .card-body { padding:1rem; }
  .fallback .btn { padding:.4rem .6rem; border:1px solid #c2c8d0; background:#f3f5f8; color:#1f2933; border-radius:.4rem; cursor:pointer; }
  .fallback .btn-primary { background:#0d6efd; color:#ffffff; border-color:#0d6efd; }
  .fallback .btn-outline-secondary,
  .fallback .btn-outline-dark { background:transparent; color:#1f2933; border-color:#c2c8d0; }
  .fallback .btn-outline-danger { background:transparent; color:#b42318; border-color:#e29f9e; }
  .fallback .badge { display:inline-block; padding:.2rem .4rem; border:1px solid #d0d7de; border-radius:.4rem; color:#4a5563; }
  .fallback table { width:100%; border-collapse:collapse; }
  .fallback th, .fallback td { border-bottom:1px solid #e5e9f2; padding:.5rem; vertical-align:top; }
  .toast-save { position: fixed; right: 1rem; bottom: 1rem; background:#ffffff; border:1px solid #d0d7de; padding:.4rem .6rem; border-radius:.4rem; box-shadow:0 6px 18px rgba(15,23,42,.2); transition:opacity .2s ease; }
  .fallback .ms-1 { margin-left:.25rem; }
  /* Custom modal fallback */
  .modal-fb { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; }
  .modal-fb.show { display:flex; }
  .modal-fb .panel { width:min(560px,95vw); background:#ffffff; border:1px solid #d0d7de; border-radius:.6rem; overflow:hidden; }
  .modal-fb header, .modal-fb .actions { padding:.75rem 1rem; border-bottom:1px solid #d0d7de; }
  .modal-fb .content { padding:1rem; }
  .form-grid { display:grid; grid-template-columns:1fr; gap:.5rem; }
  @media(min-width:760px){ .form-grid { grid-template-columns: 1fr 1fr; } .form-grid .full { grid-column:1 / -1; } }
  .input, select, textarea { width:100%; padding:.5rem .6rem; border:1px solid #c2c8d0; border-radius:.4rem; background:#ffffff; color:#1f2933; }
  .notes-pre { background:#f3f4f6; padding:.75rem; border-radius:.5rem; max-height:240px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .notes-list ol { padding-left:1.25rem; margin-bottom:0; }
  .notes-list li + li { margin-top:.5rem; }
  .notes-list time { display:block; font-size:.875rem; color:#64748b; }
  #localTable { font-size: clamp(.78rem, .74rem + .25vw, .95rem); }
  #localTable th { font-size: clamp(.7rem, .66rem + .22vw, .85rem); }
  #localTable td { line-height: 1.35; }
  #viewAssetModal td { white-space: pre-wrap; }
.sortable { cursor:pointer; user-select:none; }
  .sortable .sort-indicator { margin-left:.25rem; font-size:.75rem; color:#94a3b8; }
  .sortable.sorted .sort-indicator { color:#0d6efd; }
  #localTable td { word-break: break-word; }
  #localTable td[data-k="meta"] { white-space: nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 160px; display:none; }
  #localTable td.note-actions { white-space: nowrap; vertical-align: middle; }
  #localTable td.note-actions .btn { padding:.25rem .55rem; font-size:.75rem; }
  #lastSaved { white-space: nowrap; }

  .header-actions { display:flex; gap:.5rem; }
  .header-actions .btn { white-space: nowrap; }
  .card-header.flex-responsive { display:flex; align-items:center; gap:.75rem; }
  .card-header.flex-responsive .header-title { display:flex; align-items:center; flex-wrap:wrap; gap:.5rem; }
  .card-header.flex-responsive .header-actions { margin-left:auto; }
  @media (max-width: 992px){
    .card-header.flex-responsive { flex-direction:column; align-items:flex-start; }
    .card-header.flex-responsive .header-actions { width:100%; flex-wrap:wrap; margin-left:0; }
    .card-header.flex-responsive .header-actions .btn { flex:1 1 160px; }
    #localTable { font-size: clamp(.72rem, .68rem + .2vw, .88rem); }
    #localTable th { font-size: clamp(.66rem, .62rem + .18vw, .8rem); }
  }
  @media (max-width: 768px){
    #localTable { font-size: clamp(.68rem, .64rem + .18vw, .82rem); }
    #localTable th { font-size: clamp(.6rem, .56rem + .16vw, .76rem); }
  }
  @media (max-width: 576px){
    #localTable td.note-actions { display:flex; flex-direction:column; gap:.25rem; align-items:stretch; }
    #localTable td.note-actions .btn { width:100%; }
    #localTable td.note-actions .btn.ms-1 { margin-left:0; }
    #localTable { font-size: clamp(.64rem, .6rem + .16vw, .78rem); }
    #localTable th { font-size: clamp(.58rem, .54rem + .14vw, .72rem); }
    .card-header.flex-responsive .header-actions .btn { flex:1 0 calc(50% - .25rem); }
  }
  .fallback .d-none { display:none !important; }
  .fallback .header-actions { flex-wrap:wrap; gap:.5rem; }
  .fallback .header-actions .btn { flex:1 0 calc(50% - .25rem); }
  .fallback .note-actions { white-space:normal; display:flex; flex-direction:column; gap:.25rem; }
  .fallback .note-actions .btn { width:100%; }
  .fallback .d-none { display:none !important; }
  #viewAssetFormWrap { margin-top:1rem; }
  .fallback .sortable { cursor:pointer; }
  .fallback .sortable .sort-indicator { color:#6b7280; }
  .fallback .sortable.sorted .sort-indicator { color:#0d6efd; }
  #addModal .form-control::placeholder,
  #addModal textarea.form-control::placeholder {
    font-size:.85em;
    color:#9ca3af;
    font-weight:400;
  }
  #viewAssetModal .form-control::placeholder,
  #viewAssetModal textarea.form-control::placeholder {
    font-size:.85em;
    color:#9ca3af;
    font-weight:400;
  }
  #viewAssetDetails .meta-preview {
    max-height:180px;
    overflow:auto;
    background-color:#f8fafc;
    border:1px solid #e2e8f0;
    border-radius:.35rem;
    padding:.5rem .75rem;
  }
  #scanVideo, #scanVideoFallback {
    width:100%;
    max-height:360px;
    background:#000;
    border-radius:.5rem;
    object-fit:cover;
  }
  .scan-frame {
    position:relative;
    overflow:hidden;
    border-radius:.5rem;
  }
  .scan-frame video {
    width:100%;
    height:100%;
    object-fit:cover;
  }
  .scan-frame.front-facing video {
    object-fit:contain;
    transform:scale(0.85);
  }
  .scan-frame.front-facing {
    background:#000;
  }
  .scan-overlay {
    position:absolute;
    inset:0;
    pointer-events:none;
    display:none;
    --overlay-width: 0%;
    --overlay-height: 0%;
    --overlay-radius: .75rem;
    transition:opacity .2s ease-in-out;
  }
  .scan-overlay::after {
    content:"";
    position:absolute;
    top:50%;
    left:50%;
    width:var(--overlay-width, 0%);
    height:var(--overlay-height, 0%);
    transform:translate(-50%, -50%);
    border:2px solid #0d6efd;
    border-radius:var(--overlay-radius);
    opacity:0;
    transition:opacity .15s ease-in-out;
  }
  .scan-overlay-pane {
    position:absolute;
    background:rgba(0,0,0,.34);
    backdrop-filter:blur(6px);
    opacity:0;
    pointer-events:none;
    transition:opacity .2s ease-in-out;
  }
  .scan-overlay-pane.top {
    top:0;
    left:0;
    right:0;
    height:calc((100% - var(--overlay-height, 0%)) / 2);
  }
  .scan-overlay-pane.bottom {
    bottom:0;
    left:0;
    right:0;
    height:calc((100% - var(--overlay-height, 0%)) / 2);
  }
  .scan-overlay-pane.left {
    top:calc((100% - var(--overlay-height, 0%)) / 2);
    bottom:calc((100% - var(--overlay-height, 0%)) / 2);
    left:0;
    width:calc((100% - var(--overlay-width, 0%)) / 2);
  }
  .scan-overlay-pane.right {
    top:calc((100% - var(--overlay-height, 0%)) / 2);
    bottom:calc((100% - var(--overlay-height, 0%)) / 2);
    right:0;
    width:calc((100% - var(--overlay-width, 0%)) / 2);
  }
  .scan-overlay[data-mode="qr"],
  .scan-overlay[data-mode="barcode"] {
    display:block;
  }
  .scan-overlay[data-mode="qr"] {
    --overlay-width: 70%;
    --overlay-height: 70%;
    --overlay-radius: 1rem;
  }
  .scan-overlay[data-mode="barcode"] {
    --overlay-width: 88%;
    --overlay-height: 38%;
    --overlay-radius: 1.75rem;
  }
  .scan-overlay[data-mode="qr"]::after,
  .scan-overlay[data-mode="barcode"]::after {
    opacity:1;
  }
  .scan-overlay[data-mode="qr"] .scan-overlay-pane,
  .scan-overlay[data-mode="barcode"] .scan-overlay-pane {
    opacity:1;
  }
  @supports not ((backdrop-filter: blur(2px))) {
    .scan-overlay-pane {
      backdrop-filter:none;
      background:rgba(0,0,0,.5);
    }
  }
  #scanMatchPanel button { min-width:140px; }
  #fallbackModal .input::placeholder,
  #fallbackModal textarea.input::placeholder {
    font-size:.85em;
    color:#9ca3af;
    font-weight:400;
  }
</style>
</head>
<body>
<nav class="navbar navbar-expand-lg bg-body-tertiary fixed-top border-bottom">
  <div class="container-fluid">
    <a class="navbar-brand fw-semibold" href="#inventory">Inventory</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#topNav" aria-controls="topNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="topNav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item"><a class="nav-link" href="#inventory">Inventory</a></li>
        <li class="nav-item"><a class="nav-link" href="#diff">Change Log</a></li>
        <li class="nav-item"><a class="nav-link" href="#statuses">Settings</a></li>
      </ul>
      
    </div>
  </div>
</nav>
<div class="menu-spacer"></div>

<main class="container-fluid py-3">

  <!-- INVENTORY PAGE -->
  <section id="page-inventory" class="vis-hide">
    <div class="row g-3">
      <div class="col-12">
        <div class="card shadow-sm">
          <div class="card-header d-flex align-items-center flex-responsive">
            <div class="header-title">
              <h5 class="mb-0">Inventory</h5>
            </div>
            <div class="header-actions">
              <button class="btn btn-primary btn-sm" id="openAdd">Add asset</button>
              <button class="btn btn-outline-success btn-sm" id="openScanner">Scan barcode</button>
              <button class="btn btn-outline-danger btn-sm" id="deleteSelected">Delete selected</button>
            </div>
          </div>
          <div class="card-body pt-2">
            <div class="row g-2 align-items-end mb-3" id="localToolbar">
              <div class="col-12 col-lg-5">
                <label for="localSearch" class="form-label mb-1">Search inventory</label>
                <input id="localSearch" class="form-control form-control-sm" placeholder="Search id, serial, asset tag, assigned, status…"/>
              </div>
              <div class="col-6 col-lg-3">
                <label for="localStatusFilter" class="form-label mb-1">Status filter</label>
                <select id="localStatusFilter" class="form-select form-select-sm">
                  <option value="">All statuses</option>
                </select>
              </div>
              <div class="col-6 col-lg-2">
                <label for="localPageSize" class="form-label mb-1">Rows per page</label>
                <select id="localPageSize" class="form-select form-select-sm">
                  <option value="10">10</option>
                  <option value="25" selected>25</option>
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="all">All</option>
                </select>
              </div>
              <div class="col-12 col-lg-2 d-none d-lg-block text-lg-end text-secondary small">
                <span>Tip: click column headers to sort</span>
              </div>
            </div>
            <div id="localFilterStatus" class="small text-secondary mb-2" role="status" aria-live="polite"></div>
            <div class="table-responsive scroll-pane table-fixed-head border rounded">
              <table class="table table-sm align-middle mb-0" id="localTable">
                <thead class="table-light">
                  <tr>
                    <th style="width:36px;"><input class="form-check-input" type="checkbox" id="selAll"></th>
                    <th class="sortable" data-sort="serial_number"><span>Serial Number</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="asset_tag"><span>Asset Tag</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="type"><span>Type</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="model"><span>Model</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="room"><span>Cubicle / Office / Room</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="assigned_to"><span>Assigned To</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable" data-sort="status"><span>Status</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="sortable d-none" data-sort="meta"><span>Meta</span><span class="sort-indicator" aria-hidden="true"></span></th>
                    <th class="text-center text-nowrap">Actions</th>
                  </tr>
                </thead>
                <tbody id="localBody"></tbody>
              </table>
            </div>
            <div class="d-flex flex-column flex-md-row align-items-md-center justify-content-between mt-2 gap-2" id="localPaginationBar">
              <div id="localPaginationInfo" class="small text-secondary"></div>
              <div class="d-flex gap-2">
                <button class="btn btn-outline-secondary btn-sm" id="localPrevPage">Previous</button>
                <button class="btn btn-outline-secondary btn-sm" id="localNextPage">Next</button>
              </div>
            </div>
            <div id="localImportStatus" class="small text-secondary mt-2" role="status" aria-live="polite"></div>
          </div>
          <div class="card-footer d-flex gap-2 align-items-center flex-wrap">
            <div class="d-flex gap-2">
              <label class="btn btn-outline-dark btn-sm mb-0" for="loadLocalFile">Import Local JSON/CSV</label>
              <input type="file" id="loadLocalFile" accept=".json,.csv,text/csv,application/json" hidden/>
              <button class="btn btn-outline-dark btn-sm" id="saveLocalJson">Export Local JSON</button>
              <button class="btn btn-outline-dark btn-sm" id="saveLocalCsv">Export Local CSV</button>
            </div>
            <div class="ms-auto small text-secondary" id="lastSaved">Not yet saved</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STATUSES PAGE -->
  <section id="page-statuses" class="vis-hide">
    <div class="card shadow-sm">
      <div class="card-header"><h5 class="mb-0">Status Options</h5></div>
      <div class="card-body">
        <div class="row g-3 align-items-center">
          <div class="col-12 col-md-9">
            <label for="statusOptions" class="form-label">Statuses (comma-separated)</label>
            <input id="statusOptions" class="form-control" placeholder="e.g. In Stock, Assigned, Repair, Lost, Disposed"/>
            <div class="text-secondary mt-1">Used to populate the Add modal’s dropdown. You can still type custom statuses in the modal.</div>
          </div>
          <div class="col-12 col-md-3 d-grid d-md-flex align-items-end">
            <button class="btn btn-primary w-100" id="saveStatus">Save Status Options</button>
          </div>
        </div>
        <div class="mt-2">
          <span id="statusSaved" class="badge text-bg-secondary">Not saved</span>
        </div>
        <div class="mt-4 pt-3 border-top">
          <h6 class="mb-1">Data Management</h6>
          <p class="text-secondary small mb-3">Manage inventory data cached in this browser. Deleting storage removes saved rows and status options.</p>
          <div class="row g-2 align-items-center">
            <div class="col-12 col-md-8">
              <div id="dataStats" class="small text-secondary">Calculating storage stats…</div>
            </div>
            <div class="col-12 col-md-4 d-grid d-md-flex justify-content-md-end">
              <button class="btn btn-outline-danger w-100" id="clearIndexedDB">Delete saved data</button>
            </div>
          </div>
          <div id="dataStatus" class="small text-secondary mt-2" role="status" aria-live="polite"></div>
        </div>
        <div class="mt-4 pt-3 border-top">
          <h6 class="mb-1">Sample Dataset</h6>
          <p class="text-secondary small mb-3">Need demo data for testing or demos? Replace the current working set with 100 sample rows.</p>
          <div class="d-flex flex-wrap gap-2">
            <button class="btn btn-outline-primary" id="seedSample">Seed sample data</button>
            <div id="seedSampleStatus" class="small text-secondary align-self-center"></div>
          </div>
        </div>
      </div>
      <div class="card-footer d-flex justify-content-between">
        <a class="btn btn-outline-dark" href="#inventory">← Back to Inventory</a>
        <a class="btn btn-success" href="#diff">Go to Change Log →</a>
      </div>
    </div>
  </section>

  <!-- DIFF PAGE -->
  <section id="page-diff" class="vis-hide">
        <div class="card shadow-sm">
          <div class="card-header"><h5 class="mb-0">Change Log</h5></div>
          <div class="card-body">
            <div class="row g-3">
              <div class="col-12 col-lg-4">
                <div class="card shadow-sm mb-3">
                  <div class="card-header d-flex align-items-center">
                    <h6 class="mb-0">Inventory</h6>
                    <div class="ms-auto">
                      <button class="btn btn-outline-secondary btn-sm" id="clearOfficial">Clear</button>
                    </div>
                  </div>
                  <div class="card-body">
                    <div class="d-flex gap-2 align-items-center mb-2">
                      <label class="btn btn-outline-dark btn-sm mb-0" for="loadOfficialCsv">Import CSV</label>
                      <input type="file" id="loadOfficialCsv" accept=".csv,text/csv" hidden/>
                      <span id="officialStats" class="badge text-bg-secondary">No file loaded</span>
                    </div>
                    <p class="text-secondary mb-2">CSV must include header <span class="code">id</span>.</p>
                    <div id="officialImportStatus" class="small text-secondary mb-2" role="status" aria-live="polite"></div>
                    <div id="officialPreviewWrap" class="vis-hide">
                      <div class="table-responsive scroll-pane table-fixed-head border rounded">
                        <table class="table table-sm mb-0" id="officialPreview">
                          <thead></thead><tbody></tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="card bg-body-secondary border-0">
                  <div class="card-body">
                <div class="form-check form-switch mb-2">
                  <input class="form-check-input" type="checkbox" id="emptyClears">
                  <label class="form-check-label" for="emptyClears">Empty means “clear field”</label>
                </div>
                <div class="form-check form-switch mb-3">
                  <input class="form-check-input" type="checkbox" id="ignoreMeta">
                  <label class="form-check-label" for="ignoreMeta">Ignore <span class="code">meta</span> field</label>
                </div>
                <p class="text-secondary">Compared fields: <span class="code">serial_number</span>, <span class="code">asset_tag</span>, <span class="code">type</span>, <span class="code">model</span>, <span class="code">room</span>, <span class="code">assigned_to</span>, <span class="code">status</span>, <span class="code">meta</span> (by <span class="code">id</span>).</p>
                <div class="d-grid gap-2">
                  <button class="btn btn-primary" id="btnDiff">Generate Change Log</button>
                </div>
                <div class="mt-2">
                  <span id="diffStats" class="badge text-bg-secondary">No diff yet</span>
                </div>
              </div>
            </div>
            <div class="d-flex gap-2 mt-3">
              <button class="btn btn-outline-dark" id="downloadCsv" disabled>Download CSV</button>
              <button class="btn btn-outline-dark" id="copyMd" disabled>Copy Markdown</button>
            </div>
          </div>
          <div class="col-12 col-lg-8">
            <div class="table-responsive scroll-pane table-fixed-head border rounded">
              <table class="table table-sm mb-0" id="diffTable">
                <thead class="table-light">
                  <tr>
                    <th>Action</th><th>Tag</th><th>Field</th><th>OldValue</th><th>NewValue</th><th>Notes</th>
                  </tr>
                </thead>
                <tbody id="diffBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      
    </div>
  </section>

</main>

<!-- Add Asset Modal (Bootstrap) -->
<div class="modal fade" id="addModal" tabindex="-1" aria-labelledby="addTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="addTitle">Add Asset</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row g-3">
          <div class="col-12 col-md-6">
            <label for="m_serial_number" class="form-label">Serial Number</label>
            <input id="m_serial_number" class="form-control" placeholder="optional"/>
          </div>
          <div class="col-12 col-md-6">
            <label for="m_asset_tag" class="form-label">Asset Tag</label>
            <input id="m_asset_tag" class="form-control" placeholder="optional"/>
          </div>
          <div class="col-12 col-md-6">
            <label for="m_type" class="form-label">Type</label>
            <input id="m_type" class="form-control" placeholder="optional" list="typeSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
          </div>
          <div class="col-12 col-md-6">
            <label for="m_model" class="form-label">Model</label>
            <input id="m_model" class="form-control" placeholder="optional" list="modelSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
          </div>
          <div class="col-12 col-md-6">
            <label for="m_room" class="form-label">Cubicle / Office / Room</label>
            <input id="m_room" class="form-control" placeholder="optional" list="roomSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
          </div>
          <div class="col-12 col-md-6">
            <label for="m_assigned_to" class="form-label">Assigned To</label>
            <input id="m_assigned_to" class="form-control" placeholder="optional" list="assignedSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
          </div>
          <div class="col-12">
            <label class="form-label">Status</label>
            <div class="input-group">
              <select id="m_status" class="form-select"></select>
              <input id="m_status_custom" class="form-control" placeholder="or type custom…"/>
            </div>
            <div class="text-secondary">Choose from the list or type your own.</div>
          </div>
          <div class="col-12">
            <label for="m_meta" class="form-label">Meta (JSON or text)</label>
            <textarea id="m_meta" class="form-control" rows="3" placeholder='e.g. {"color":"black","cost":999}'></textarea>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="confirmAdd">Add</button>
      </div>
    </div>
  </div>
</div>

<!-- Fallback Modal (if Bootstrap JS unavailable) -->
<div id="fallbackModal" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header><strong>Add Asset</strong></header>
    <div class="content">
      <div class="form-grid">
        <div>
          <label>Serial Number</label>
          <input id="fb_serial_number" class="input" placeholder="optional"/>
        </div>
        <div>
          <label>Asset Tag</label>
          <input id="fb_asset_tag" class="input" placeholder="optional"/>
        </div>
        <div>
          <label>Type</label>
          <input id="fb_type" class="input" placeholder="optional" list="typeSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
        </div>
        <div>
          <label>Model</label>
          <input id="fb_model" class="input" placeholder="optional" list="modelSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
        </div>
        <div>
          <label>Cubicle / Office / Room</label>
          <input id="fb_room" class="input" placeholder="optional" list="roomSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
        </div>
        <div>
          <label>Assigned To</label>
          <input id="fb_assigned_to" class="input" placeholder="optional" list="assignedSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
        </div>
        <div class="full">
          <label>Status</label>
          <div style="display:flex; gap:.5rem;">
            <select id="fb_status" class="input"></select>
            <input id="fb_status_custom" class="input" placeholder="or type custom…"/>
          </div>
        </div>
        <div class="full">
          <label>Meta (JSON or text)</label>
          <textarea id="fb_meta" class="input" rows="3" placeholder='e.g. {"color":"black","cost":999}'></textarea>
        </div>
      </div>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="fb_cancel">Cancel</button>
      <button class="btn btn-primary" id="fb_confirm">Add</button>
    </div>
  </div>
</div>

<!-- View Notes Modal -->
<div class="modal fade" id="notesModal" tabindex="-1" aria-labelledby="notesTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="notesTitle">Asset Notes</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="notesList" class="notes-list mb-3"></div>
        <div>
          <div class="small text-secondary mb-1" id="notesMetaLabel">Meta JSON</div>
          <pre id="notesMetaJson" class="notes-pre"></pre>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Add Note Modal -->
<div class="modal fade" id="noteModal" tabindex="-1" aria-labelledby="noteModalTitle" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="noteModalTitle">Add Note</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="noteText" class="form-label">Note</label>
          <textarea id="noteText" class="form-control" rows="4" placeholder="Enter details..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="noteModalSave">Save note</button>
      </div>
    </div>
  </div>
</div>

<!-- Edit Meta Modal -->
<div class="modal fade" id="metaModal" tabindex="-1" aria-labelledby="metaModalTitle" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="metaModalTitle">Meta</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <label for="metaModalText" class="form-label">Meta (stored as text/JSON)</label>
        <textarea id="metaModalText" class="form-control" rows="6" placeholder='e.g. {"color":"black"}'></textarea>
        <div class="form-text">Leave blank to clear. JSON is optional.</div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="metaModalSave">Save meta</button>
      </div>
    </div>
  </div>
</div>



<!-- View Asset Modal -->
<div class="modal fade" id="viewAssetModal" tabindex="-1" aria-labelledby="viewAssetModalTitle" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="viewAssetModalTitle">Asset Details</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="viewAssetReadOnly">
          <table class="table table-sm table-striped mb-0">
            <tbody id="viewAssetDetails"></tbody>
          </table>
        </div>
        <div id="viewAssetFormWrap" class="d-none">
          <form id="viewAssetForm" autocomplete="off" novalidate>
            <p class="small text-secondary mb-2">Edit mode is active. Update the fields below and select “Save changes”.</p>
            <div class="row g-3">
              <div class="col-12 col-md-6">
                <label for="view_edit_serial_number" class="form-label">Serial Number</label>
                <input id="view_edit_serial_number" class="form-control" type="text"/>
              </div>
              <div class="col-12 col-md-6">
                <label for="view_edit_asset_tag" class="form-label">Asset Tag</label>
                <input id="view_edit_asset_tag" class="form-control" type="text"/>
              </div>
              <div class="col-12 col-md-6">
                <label for="view_edit_type" class="form-label">Type</label>
                <input id="view_edit_type" class="form-control" type="text" list="typeSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
              </div>
              <div class="col-12 col-md-6">
                <label for="view_edit_model" class="form-label">Model</label>
                <input id="view_edit_model" class="form-control" type="text" list="modelSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
              </div>
              <div class="col-12 col-md-6">
                <label for="view_edit_room" class="form-label">Cubicle / Office / Room</label>
                <input id="view_edit_room" class="form-control" type="text" list="roomSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
              </div>
              <div class="col-12 col-md-6">
                <label for="view_edit_assigned_to" class="form-label">Assigned To</label>
                <input id="view_edit_assigned_to" class="form-control" type="text" list="assignedSuggestions" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
              </div>
              <div class="col-12">
                <label class="form-label" for="view_edit_status">Status</label>
                <div class="input-group">
                  <select id="view_edit_status" class="form-select"></select>
                  <input id="view_edit_status_custom" class="form-control" type="text" placeholder="or type custom…"/>
                </div>
              <div class="text-secondary small">Choose from the list or type your own.</div>
            </div>
            <div class="col-12">
              <label for="view_edit_meta" class="form-label">Meta (JSON or text)</label>
              <textarea id="view_edit_meta" class="form-control" rows="3" placeholder="{}"></textarea>
            </div>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-footer justify-content-between align-items-center flex-wrap gap-2">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
        <div class="d-flex flex-wrap gap-2">
          <button type="button" class="btn btn-outline-secondary d-none" id="viewAssetCancelEdit">Cancel</button>
          <button type="submit" class="btn btn-primary d-none" id="viewAssetSave" form="viewAssetForm">Save changes</button>
          <button type="button" class="btn btn-outline-dark" id="viewAssetEdit">Enter edit mode</button>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- Notes fallback (if Bootstrap JS unavailable) -->
<div id="notesFallback" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header id="notesFallbackTitle"><strong>Asset Notes</strong></header>
    <div class="content">
      <div id="notesFallbackContent" class="small"></div>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="notesFallbackClose">Close</button>
    </div>
  </div>
</div>

<!-- Note input fallback -->
<div id="noteFallback" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header id="noteFallbackTitle"><strong>Add Note</strong></header>
    <div class="content">
      <textarea id="noteFallbackText" class="input" rows="4" placeholder="Enter details..."></textarea>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="noteFallbackCancel">Cancel</button>
      <button class="btn btn-primary" id="noteFallbackSave">Save note</button>
    </div>
  </div>
</div>

<!-- Meta fallback -->
<div id="metaFallback" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header id="metaFallbackTitle"><strong>Meta</strong></header>
    <div class="content">
      <textarea id="metaFallbackText" class="input" rows="6" placeholder='e.g. {"color":"black"}'></textarea>
      <div class="small text-secondary" style="margin-top:.5rem;">Leave blank to clear. JSON is optional.</div>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="metaFallbackCancel">Cancel</button>
      <button class="btn btn-primary" id="metaFallbackSave">Save meta</button>
    </div>
  </div>
</div>

<!-- Seed sample confirm (Bootstrap) -->
<div class="modal fade" id="seedConfirmModal" tabindex="-1" aria-labelledby="seedConfirmTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="seedConfirmTitle">Seed Sample Data</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-0">Replace the current inventory with 100 sample rows? This will overwrite any unsaved changes.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal" id="seedConfirmCancel">Cancel</button>
        <button type="button" class="btn btn-primary" id="seedConfirmConfirm">Seed sample data</button>
      </div>
    </div>
  </div>
</div>

<!-- Seed sample confirm (fallback) -->
<div id="seedConfirmFallback" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header><strong>Seed Sample Data</strong></header>
    <div class="content">
      <p class="mb-0">Replace the current inventory with 100 sample rows? This will overwrite any unsaved changes.</p>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="seedConfirmFallbackCancel">Cancel</button>
      <button class="btn btn-primary" id="seedConfirmFallbackConfirm">Seed sample data</button>
    </div>
  </div>
</div>

<!-- Barcode scanner modal -->
<div class="modal fade" id="scanModal" tabindex="-1" aria-labelledby="scanModalTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="scanModalTitle">Scan Barcode</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="ratio ratio-4x3 border rounded scan-frame">
          <video id="scanVideo" autoplay playsinline muted></video>
          <div id="scanOverlay" class="scan-overlay" aria-hidden="true">
            <span class="scan-overlay-pane top"></span>
            <span class="scan-overlay-pane bottom"></span>
            <span class="scan-overlay-pane left"></span>
            <span class="scan-overlay-pane right"></span>
          </div>
        </div>
        <div class="d-flex flex-column flex-md-row align-items-md-center gap-2 mt-3">
          <div class="d-flex flex-wrap gap-1 align-items-center">
            <button class="btn btn-outline-secondary btn-sm" id="scanFlip">Switch camera</button>
            <label for="scanZoomSlider" class="form-label small mb-0 ms-2">Zoom</label>
            <input type="range" min="0" max="100" value="0" id="scanZoomSlider" class="form-range" style="width:160px"/>
            <button type="button" class="btn btn-outline-secondary btn-sm ms-2" id="scanOverlayToggle">Overlay: None</button>
          </div>
          <small class="text-secondary" id="scanZoomStatus"></small>
        </div>
        <div class="mt-3">
          <div id="scanStatus" class="small text-secondary" role="status" aria-live="polite">Initializing camera…</div>
        </div>
        <div id="scanMatchPanel" class="alert alert-info mt-3 d-none">
          <h6 class="alert-heading mb-2">Potential match</h6>
          <div id="scanDetected" class="fw-semibold"></div>
          <div id="scanMatchInfo" class="small text-secondary mt-1"></div>
          <div class="d-flex flex-wrap gap-2 mt-3">
            <button class="btn btn-success" id="scanConfirm">Confirm match</button>
            <button class="btn btn-outline-primary d-none" id="scanEdit">Open in edit</button>
            <button class="btn btn-outline-primary d-none" id="scanAdd">Add new asset</button>
            <button class="btn btn-outline-secondary" id="scanIgnore">Ignore</button>
          </div>
        </div>
        <div class="mt-4">
          <label for="manualScanInput" class="form-label small">Manual lookup</label>
          <div class="input-group">
            <input id="manualScanInput" class="form-control" placeholder="Enter or paste serial number"/>
            <button class="btn btn-outline-primary" id="manualScanSubmit">Find</button>
          </div>
          <div id="manualScanStatus" class="small text-secondary mt-2"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" id="scanStop">Stop scanning</button>
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Barcode scanner fallback -->
<div id="scanFallback" class="modal-fb" aria-hidden="true">
  <div class="panel">
    <header><strong>Scan Barcode</strong></header>
    <div class="content">
      <div class="scan-frame border rounded">
        <video id="scanVideoFallback" autoplay playsinline muted></video>
        <div id="scanOverlayFallback" class="scan-overlay" aria-hidden="true">
          <span class="scan-overlay-pane top"></span>
          <span class="scan-overlay-pane bottom"></span>
          <span class="scan-overlay-pane left"></span>
          <span class="scan-overlay-pane right"></span>
        </div>
      </div>
      <div class="d-flex flex-wrap gap-2 mt-2 align-items-center">
        <button type="button" class="btn" id="scanFlipFallback">Switch camera</button>
        <label for="scanZoomSliderFallback" class="small mb-0">Zoom</label>
        <input type="range" min="0" max="100" value="0" id="scanZoomSliderFallback" class="input" style="flex:1"/>
        <button type="button" class="btn btn-outline-secondary" id="scanOverlayToggleFallback">Overlay: None</button>
        <small class="text-secondary" id="scanZoomStatusFallback"></small>
      </div>
      <div id="scanStatusFallback" class="small text-secondary mt-2" role="status" aria-live="polite">Initializing camera…</div>
      <div id="scanMatchPanelFallback" class="alert alert-info mt-3 d-none">
        <h6 class="alert-heading mb-2">Potential match</h6>
        <div id="scanDetectedFallback" class="fw-semibold"></div>
        <div id="scanMatchInfoFallback" class="small text-secondary mt-1"></div>
        <div class="d-flex flex-wrap gap-2 mt-3">
          <button class="btn btn-success" id="scanConfirmFallback">Confirm match</button>
          <button class="btn btn-outline-primary d-none" id="scanEditFallback">Open in edit</button>
          <button class="btn btn-outline-primary d-none" id="scanAddFallback">Add new asset</button>
          <button class="btn btn-outline-secondary" id="scanIgnoreFallback">Ignore</button>
        </div>
      </div>
      <div class="mt-3">
        <label for="manualScanInputFallback" class="form-label small">Manual lookup</label>
        <div class="input-group">
          <input id="manualScanInputFallback" class="input" placeholder="Enter serial number"/>
          <button class="btn btn-outline-primary" id="manualScanSubmitFallback">Find</button>
        </div>
        <div id="manualScanStatusFallback" class="small text-secondary mt-2"></div>
      </div>
    </div>
    <div class="actions" style="display:flex; gap:.5rem; justify-content:flex-end; padding:.75rem 1rem;">
      <button class="btn" id="scanStopFallback">Stop scanning</button>
      <button class="btn btn-primary" id="scanCloseFallback">Close</button>
    </div>
  </div>
</div>


<!-- Suggested value lists -->
<datalist id="typeSuggestions"></datalist>
<datalist id="modelSuggestions"></datalist>
<datalist id="roomSuggestions"></datalist>
<datalist id="assignedSuggestions"></datalist>

<!-- Toast containers -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <div id="toastSave" class="toast text-bg-success border-0" role="status" aria-live="polite" aria-atomic="true" data-bs-autohide="true" data-bs-delay="2400">
    <div class="d-flex align-items-center">
      <div class="toast-body">Saved.</div>
      <button type="button" class="btn-close btn-close-white ms-2 me-1" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
  </div>
</div>
<div id="toastSaveFallback" class="toast-save vis-hide">Saved.</div>

<!-- Primary Bootstrap Bundle -->
<script id="bs-js-1" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" defer></script>
<!-- Secondary Bootstrap Bundles (disabled initially) -->
<script id="bs-js-2" src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.3/js/bootstrap.bundle.min.js" defer disabled></script>
<script id="bs-js-3" src="https://unpkg.com/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" defer disabled></script>
<script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" defer></script>

<script>
// ===== Bootstrap load watchdog & fallbacks =====
function bootstrapLoaded() { return !!window.bootstrap; }
function enableAltCDNs(){
  document.getElementById('bs-css-2').disabled = false;
  document.getElementById('bs-css-3').disabled = false;
  document.getElementById('bs-js-2').removeAttribute('disabled');
  document.getElementById('bs-js-3').removeAttribute('disabled');
}
function markFallbackUI(){
  // add .fallback class to body for minimal styles
  document.body.classList.add('fallback');
}

function setupResponsiveNav(){
  const toggler = document.querySelector('.navbar-toggler');
  const menu = document.getElementById('topNav');
  if(!toggler || !menu) return;

  const usingBootstrap = ()=> !!(window.bootstrap && window.bootstrap.Collapse);
  const ensureCollapse = ()=> usingBootstrap() ? window.bootstrap.Collapse.getOrCreateInstance(menu, { toggle:false }) : null;
  const applyFallbackState = open => {
    menu.classList.toggle('show', open);
    menu.style.display = open ? 'block' : '';
    toggler.setAttribute('aria-expanded', open ? 'true' : 'false');
  };
  const isOpen = ()=> {
    if(usingBootstrap()){
      return menu.classList.contains('show');
    }
    return menu.classList.contains('show') || menu.style.display === 'block';
  };
  const hideMenu = ()=>{
    if(usingBootstrap()){
      ensureCollapse()?.hide();
    } else {
      applyFallbackState(false);
    }
  };
  const showMenu = ()=>{
    if(usingBootstrap()){
      ensureCollapse()?.show();
    } else {
      applyFallbackState(true);
    }
  };

  if(!usingBootstrap()){
    toggler.addEventListener('click', ev=>{
      ev.preventDefault();
      if(isOpen()) hideMenu();
      else showMenu();
    });
  } else {
    toggler.addEventListener('click', ()=>{
      if(isOpen()) hideMenu();
    });
  }

  menu.querySelectorAll('.nav-link').forEach(link => {
    link.addEventListener('click', hideMenu);
  });

  document.addEventListener('click', ev=>{
    if(!isOpen()) return;
    if(menu.contains(ev.target) || toggler.contains(ev.target)) return;
    hideMenu();
  });

  window.addEventListener('hashchange', hideMenu);

  if(!usingBootstrap()){
    applyFallbackState(false);
  }
}

let bootstrapCheckTries = 0;
function checkBootstrap(){
  if(bootstrapLoaded()) return; // good
  bootstrapCheckTries++;
  if(bootstrapCheckTries === 2){
    // first retry: enable alt CDNs
    enableAltCDNs();
  }
  if(bootstrapCheckTries > 5){
    // give up: offline fallback
    markFallbackUI();
    console.warn('Bootstrap not available; using offline fallback UI.');
    return;
  }
  setTimeout(checkBootstrap, 600);
}
checkBootstrap();
</script>

<script>
// ======= Simple hash router =======
const routes = { "#inventory":"page-inventory", "#statuses":"page-statuses", "#diff":"page-diff" };
function showRoute() {
  const hash = location.hash || "#inventory";
  for (const id of Object.values(routes)) document.getElementById(id).classList.add("vis-hide");
  const pageId = routes[hash] || "page-inventory";
  document.getElementById(pageId).classList.remove("vis-hide");
  document.querySelectorAll(".nav-link").forEach(a => a.classList.toggle("active", a.getAttribute("href") === hash));
}
window.addEventListener("hashchange", showRoute);
window.addEventListener("DOMContentLoaded", showRoute);
window.addEventListener("DOMContentLoaded", setupResponsiveNav);

// ======= IndexedDB kv =======
const DB_NAME = 'inventoryDB';
const DB_VERSION = 4;
const STORE = 'kv';
const IDB_KEY_ROWS = 'localRows';
const IDB_KEY_STATUS = 'statusOptions';
const LS_KEY_MIGRATION = 'inv.local.rows.v1';

function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e)=>{
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)){
        db.createObjectStore(STORE, { keyPath: 'key' });
      }
    };
    req.onsuccess = ()=>{
      const db = req.result;
      db.onversionchange = ()=> db.close();
      resolve(db);
    };
    req.onerror = ()=> reject(req.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const req = st.get(key);
    tx.oncomplete = ()=> db.close();
    tx.onabort = ()=> db.close();
    req.onsuccess = ()=> resolve(req.result ? req.result.value : undefined);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readwrite');
    const st = tx.objectStore(STORE);
    const req = st.put({ key, value });
    tx.oncomplete = ()=> db.close();
    tx.onabort = ()=> db.close();
    req.onsuccess = ()=> resolve(true);
    req.onerror = ()=> reject(req.error);
  });
}

// ======= Utilities =======
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const textEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
function norm(v){ return (v ?? '').toString().trim(); }
function toMapById(rows){ const m = new Map(); for(const r of rows){ const id = norm(r.id); if(id) m.set(id, r); } return m; }
function formatBytes(bytes){
  if(!Number.isFinite(bytes) || bytes <= 0) return "0 B";
  const units = ["B","KB","MB","GB","TB"];
  let value = bytes;
  let unit = 0;
  while(value >= 1024 && unit < units.length - 1){
    value /= 1024;
    unit++;
  }
  const decimals = value >= 10 || unit === 0 ? 0 : 1;
  return `${value.toFixed(decimals)} ${units[unit]}`;
}
function estimateSize(value){
  try {
    const json = typeof value === "string" ? value : JSON.stringify(value ?? "");
    if(textEncoder) return textEncoder.encode(json).length;
    return json.length;
  } catch {
    return 0;
  }
}

function parseCSV(text){
  const rows = []; let i=0, cur='', inQ=false, row=[];
  const pushCell=()=>{ row.push(cur); cur=''; }, pushRow=()=>{ rows.push(row); row=[]; };
  while(i<text.length){
    const ch=text[i++];
    if(inQ){
      if(ch === '"'){ if(text[i] === '"'){ cur += '"'; i++; } else { inQ=false; } }
      else { cur += ch; }
    } else {
      if(ch === '"'){ inQ=true; }
      else if(ch === ','){ pushCell(); }
      else if(ch === '\r'){}
      else if(ch === '\n'){ pushCell(); pushRow(); }
      else { cur += ch; }
    }
  }
  pushCell(); pushRow();
  if(rows.length && rows[rows.length-1].every(c=>c==='')) rows.pop();
  if(rows.length===0) return {headers:[],rows:[]};
  const headers = rows[0].map(h=>h.trim().replace(/^\ufeff/, ""));
  const outRows = rows.slice(1).map(r => {
    const obj = {}; headers.forEach((h,idx)=> obj[h] = (r[idx] ?? '').trim()); return obj;
  });
  return { headers, rows: outRows };
}

function normalizeCSVText(text){
  if(!text) return text;
  let t = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  while(t.includes("\\n")){
    t = t.replace(/\\n/g, "\n");
  }
  return t;
}
function toCSV(rows){
  const cols = ["Action","Tag","Field","OldValue","NewValue","Notes"];
  const esc = v => `"${String(v ?? '').replace(/"/g,'""')}"`;
  const head = cols.join(",");
  const lines = rows.map(r => cols.map(c => esc(r[c])).join(","));
  return [head,...lines].join("\n");
}
function toMarkdown(rows){
  const cols = ["Action","Tag","Field","OldValue","NewValue","Notes"];
  const head = `| ${cols.join(" | ")} |\n| ${cols.map(()=>"-").join(" | ")} |`;
  const lines = rows.map(r => `| ${cols.map(c => String(r[c] ?? "")).join(" | ")} |`);
  return [head, ...lines].join("\n");
}

// ======= Save Toast (Bootstrap or fallback) =======
const lastSavedEl = document.getElementById('lastSaved');
function updateLastSaved(){
  if(!lastSavedEl) return;
  const ts = new Date();
  const hh = String(ts.getHours()).padStart(2,'0');
  const mm = String(ts.getMinutes()).padStart(2,'0');
  const ss = String(ts.getSeconds()).padStart(2,'0');
  lastSavedEl.textContent = `Last saved at ${hh}:${mm}:${ss}`;
}
function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
function setStatus(id, message, variant="info"){
  const el = document.getElementById(id);
  if(!el) return;
  const variants = { info: "text-secondary", success: "text-success", error: "text-danger" };
  el.classList.remove("text-secondary","text-success","text-danger");
  const cls = variants[variant] || variants.info;
  el.classList.add(cls);
  el.textContent = message || "";
}
let toastFallbackTimer = null;
function showSavedToast(message, fallbackStatusId){
  const text = message || "Saved.";
  const hasBootstrapToast = !!(window.bootstrap && typeof window.bootstrap.Toast === "function");
  const toastEl = hasBootstrapToast ? document.getElementById("toastSave") : null;
  if(toastEl){
    const body = toastEl.querySelector(".toast-body");
    if(body) body.textContent = text;
    const toast = bootstrap.Toast.getOrCreateInstance(toastEl);
    toast.show();
  } else {
    const fallbackEl = document.getElementById("toastSaveFallback");
    if(fallbackEl){
      fallbackEl.textContent = text;
      fallbackEl.classList.remove("vis-hide");
      fallbackEl.style.opacity = "1";
      clearTimeout(toastFallbackTimer);
      toastFallbackTimer = setTimeout(()=>{
        fallbackEl.style.opacity = "0";
        setTimeout(()=> fallbackEl.classList.add("vis-hide"), 200);
      }, 2000);
    }
  }
  if(fallbackStatusId){
    setStatus(fallbackStatusId, text, "success");
  }
}

// ======= Local Working Set =======
const localCols = ["serial_number","asset_tag","type","model","room","assigned_to","status","meta"];
const SUGGESTION_FIELDS = {
  type: "typeSuggestions",
  model: "modelSuggestions",
  room: "roomSuggestions",
  assigned_to: "assignedSuggestions"
};
const SUGGESTION_MAX_ITEMS = 100;
const VIEW_MODAL_FIELDS = [
  { label: "Record ID", aliases: ["id", "RecordID", "AssetID"] },
  { label: "Name", aliases: ["name", "Name"] },
  { label: "Serial Number", aliases: ["serial_number", "SerialNumber"] },
  { label: "Asset Tag", aliases: ["asset_tag", "AssetTag"] },
  { label: "Status", aliases: ["status", "Status"] },
  { label: "Type", aliases: ["type", "Type"] },
  { label: "Model", aliases: ["model", "Model"] },
  { label: "Device Name", aliases: ["device_name", "DeviceName"] },
  { label: "Assigned To", aliases: ["assigned_to", "AssignedTo"] },
  { label: "Assigned Location", aliases: ["assigned_to_location", "AssignedToLocation"] },
  { label: "Asset Location", aliases: ["asset_location", "AssetLocation", "Location"] },
  { label: "Cubicle / Office / Room", aliases: ["room", "Cubicle/Office/Room", "Cubicle", "Office", "Room"] },
  { label: "Description", aliases: ["description", "Description"] },
  { label: "Managed By", aliases: ["managed_by", "ManagedBy"] },
  { label: "Created By", aliases: ["created_by", "CreatedBy"] },
  { label: "Created Date", aliases: ["created_date", "CreatedDate"] },
  { label: "Modified By", aliases: ["modified_by", "ModifiedBy"] },
  { label: "Modified Date", aliases: ["modified_date", "ModifiedDate"] },
  { label: "Survey Number", aliases: ["survey_number", "SurveyNumber"] },
  { label: "Disposal Reason", aliases: ["disposal_reason", "DisposalReason"] }
];
// Limit for inline meta previews inside the view modal.
const META_PREVIEW_LIMIT = 400;
const tableState = { search:"", status:"", sortBy:"serial_number", sortDir:"asc", page:1, pageSize:"25" };
let pendingRefreshOpts = {};
let refreshTimeout = null;
const SORTABLE_COLS = new Set(localCols.concat("meta"));
function queueTableRefresh(opts){
  pendingRefreshOpts = Object.assign(pendingRefreshOpts, opts || {});
  if(refreshTimeout) return;
  refreshTimeout = setTimeout(()=>{
    const nextOpts = pendingRefreshOpts;
    pendingRefreshOpts = {};
    refreshTimeout = null;
    refreshLocalView(nextOpts);
  }, 40);
}
function normalizeFieldKey(key){
  return (key ?? "").toString().replace(/[^a-z0-9]/gi, "").toLowerCase();
}
// Capture field names already shown in the table so we can hide duplicates from meta.
const RESERVED_META_KEYS = (() => {
  const reserved = new Set(localCols.map(normalizeFieldKey));
  VIEW_MODAL_FIELDS.forEach(field => {
    (field.aliases || []).forEach(alias => reserved.add(normalizeFieldKey(alias)));
  });
  reserved.delete("");
  reserved.delete(normalizeFieldKey("meta"));
  return reserved;
})();
function findMatchingKey(src, alias){
  const target = normalizeFieldKey(alias);
  if(!target) return undefined;
  for(const key of Object.keys(src || {})){
    if(normalizeFieldKey(key) === target){
      return key;
    }
  }
  return undefined;
}
function grab(src, ...aliases){
  for(const alias of aliases){
    const match = findMatchingKey(src, alias);
    if(match !== undefined) return src[match];
  }
  return undefined;
}
function upgradeRow(raw){
  const src = raw || {};
  const usedKeys = new Set();
  const take = (...aliases) => {
    for(const alias of aliases){
      const match = findMatchingKey(src, alias);
      if(match !== undefined){
        usedKeys.add(match);
        return src[match];
      }
    }
    return undefined;
  };
  const metaSource = take("meta","metadata","notes");
  const baseMeta = metaSource !== undefined ? parseMeta(metaSource) : {};
  const result = {
    id: norm(take("id","assetid","recordid","tag")),
    serial_number: norm(take("serialnumber","serial","serialno","serial_number")),
    asset_tag: norm(take("assettag","asset_tag","assetnumber","inventorytag")),
    type: norm(take("type","category","devicetype")),
    model: norm(take("model","modelnumber")),
    room: norm(take("cubicleofficeroom","cubicle","office","room","workspace","locationdetail")) || norm(take("location")),
    assigned_to: norm(take("assigned_to","assignedto","assignedperson","holder","assignee","deviceuser")),
    status: norm(take("status","state"))
  };
  const extras = { ...baseMeta };
  for(const [key, value] of Object.entries(src)){
    if(usedKeys.has(key)) continue;
    if(value === undefined || value === null) continue;
    if(typeof value === "string" && value.trim() === "") continue;
    extras[key] = value;
  }
  if(!result.id){
    if(result.asset_tag) result.id = result.asset_tag;
    else if(result.serial_number) result.id = result.serial_number;
  }
  const metaString = Object.keys(extras).length ? JSON.stringify(extras) : "";
  result.meta = metaString;
  return result;
}
function createSeedRows(count=100){
  const types = [
    { type:"Computer", model:"15\" Laptop Pro", name:"Laptop" },
    { type:"Monitor", model:"24\" UltraSharp", name:"Monitor" },
    { type:"Dock", model:"USB-C Dock Gen2", name:"Dock" }
  ];
  const assignedPeople = ["Jamie West","Keith Ross","Taylor Morgan","Alex Rivera","Jordan Blake","Morgan Lee","Sam Patel","Riley Chen","Casey Morgan","Avery Scott"];
  const managers = ["Keith Ross","Morgan Lee","Riley Chen","Avery Scott"];
  const locations = ["Riverside Annex","HQ North","Warehouse B","Innovation Lab","Remote Storage"];
  const rooms = ["Cubicle","Office","Room","Hot Desk","Studio"];
  const statuses = ["In Stock","Assigned","Repair","Lost","Disposed"];
  const descriptions = [
    "Installed last week",
    "Ready for deployment",
    "Awaiting pickup",
    "Returned for diagnostics",
    "Staged for refresh",
    "Decommission scheduled"
  ];
  const createdDates = [
    "Friday, June 20, 2025",
    "Monday, July 1, 2025",
    "Tuesday, July 15, 2025",
    "Wednesday, August 6, 2025"
  ];
  const modifiedDates = [
    "Thursday, June 21, 2025",
    "Tuesday, July 8, 2025",
    "Friday, July 25, 2025",
    "Monday, August 11, 2025"
  ];
  const disposalReasons = ["Obsolete","Damaged","Upgraded","Replaced","Reassigned"];
  const rows = [];
  for(let i=0; i<count; i++){
    const typeInfo = types[i % types.length];
    const assigned = assignedPeople[i % assignedPeople.length];
    const manager = managers[i % managers.length];
    const location = locations[i % locations.length];
    const room = `${rooms[i % rooms.length]} ${((i % 20) + 1)}`;
    const status = statuses[i % statuses.length];
    const description = descriptions[i % descriptions.length];
    const createdDate = createdDates[i % createdDates.length];
    const modifiedDate = modifiedDates[i % modifiedDates.length];
    const surveyNumber = `PSR-${(23 + (i % 3)).toString().padStart(2,'0')}-${(1920 + i).toString().padStart(4,'0')}`;
    const disposalReason = disposalReasons[i % disposalReasons.length];
    const idNumber = 46625 + i;
    const serialNumber = 480000 + i;
    const assetTagNumber = 92800 + i;
    const deviceSuffix = (123200 + i).toString();
    const record = {
      ID: `CI-${idNumber}`,
      Name: `${typeInfo.name}`,
      Model: typeInfo.model,
      Type: typeInfo.type,
      AssetTag: `AT-${assetTagNumber}`,
      SerialNumber: `SN-${serialNumber}`,
      Status: status,
      DeviceName: `${assigned.split(" ").map(w=>w[0]).join("").toUpperCase()}-${deviceSuffix}`,
      AssignedTo: assigned,
      ManagedBy: manager,
      Location: location,
      "Cubicle/Office/Room": room,
      Description: description,
      CreatedBy: manager,
      CreatedDate: createdDate,
      ModifiedBy: assigned,
      ModifiedDate: modifiedDate,
      SurveyNumber: surveyNumber,
      DisposalReason: disposalReason
    };
    rows.push(record);
  }
  return rows;
}
const localBody = $("#localBody"); const selAll = $("#selAll");
const viewModalEl = document.getElementById("viewAssetModal");
const viewModalTitle = document.getElementById("viewAssetModalTitle");
const viewModalDetails = document.getElementById("viewAssetDetails");
const viewModalReadOnly = document.getElementById("viewAssetReadOnly");
const viewModalFormWrap = document.getElementById("viewAssetFormWrap");
const viewModalForm = document.getElementById("viewAssetForm");
const viewModalEditBtn = document.getElementById("viewAssetEdit");
const viewModalCancelBtn = document.getElementById("viewAssetCancelEdit");
const viewModalSaveBtn = document.getElementById("viewAssetSave");
const viewModalStatusSelect = document.getElementById("view_edit_status");
const viewModalStatusCustom = document.getElementById("view_edit_status_custom");
const viewFormInputs = {
  serial_number: document.getElementById("view_edit_serial_number"),
  asset_tag: document.getElementById("view_edit_asset_tag"),
  type: document.getElementById("view_edit_type"),
  model: document.getElementById("view_edit_model"),
  room: document.getElementById("view_edit_room"),
  assigned_to: document.getElementById("view_edit_assigned_to"),
  meta: document.getElementById("view_edit_meta")
};
let viewModalInstance = null;
let currentViewRow = null;
let viewEditModeActive = false;
if(viewModalEl && window.bootstrap){
  viewModalInstance = new bootstrap.Modal(viewModalEl);
}
function rowToObj(tr){
  const tds = Array.from(tr.querySelectorAll("td[data-k]"));
  const obj = {};
  tds.forEach(td => obj[td.dataset.k] = td.textContent.trim());
  if(tr?.dataset?.id){
    obj.id = tr.dataset.id;
  }
  return obj;
}
function objToRow(obj){
  const tr = document.createElement("tr");
  if(obj && obj.id !== undefined) tr.dataset.id = obj.id;
  const tdSel = document.createElement("td"); tdSel.innerHTML = '<input class="form-check-input selRow" type="checkbox">'; tr.appendChild(tdSel);
  for(const k of localCols){
    const td = document.createElement("td");
    td.dataset.k = k;
    const value = k === "meta" ? asMetaText(obj?.meta) : (obj?.[k] ?? "");
    td.textContent = value;
    tr.appendChild(td);
  }
  const tdActions = document.createElement("td");
  tdActions.className = "text-center text-nowrap";
  const viewLink = document.createElement("a");
  viewLink.href = "#";
  viewLink.textContent = "View";
  viewLink.addEventListener("click", ev => {
    ev.preventDefault();
    ev.stopPropagation();
    openViewAsset(tr, { edit: false });
  });
  const separator = document.createTextNode(" | ");
  const editLink = document.createElement("a");
  editLink.href = "#";
  editLink.textContent = "Edit";
  editLink.addEventListener("click", ev => {
    ev.preventDefault();
    ev.stopPropagation();
    openViewAsset(tr, { edit: true });
  });
  tdActions.append(viewLink, separator, editLink);
  tr.appendChild(tdActions);
  return tr;
}
function updateSuggestionDatalists(rows){
  const buckets = {};
  for(const key of Object.keys(SUGGESTION_FIELDS)){
    buckets[key] = new Set();
  }
  (rows || []).forEach(row => {
    for(const key of Object.keys(SUGGESTION_FIELDS)){
      const raw = row?.[key];
      if(raw === undefined || raw === null) continue;
      const text = typeof raw === "string" ? raw.trim() : String(raw).trim();
      if(text) buckets[key].add(text);
    }
  });
  for(const [key, datalistId] of Object.entries(SUGGESTION_FIELDS)){
    const datalist = document.getElementById(datalistId);
    if(!datalist) continue;
    datalist.textContent = "";
    Array.from(buckets[key])
      .sort((a, b)=> a.localeCompare(b, undefined, { sensitivity:"base" }))
      .slice(0, SUGGESTION_MAX_ITEMS)
      .forEach(value => {
        const opt = document.createElement("option");
        opt.value = value;
        datalist.appendChild(opt);
      });
  }
}
function refreshFieldSuggestions(){
  const rows = readLocal().map(upgradeRow);
  updateSuggestionDatalists(rows);
}
function renderLocal(rows){
  localBody.innerHTML = "";
  (rows || []).map(upgradeRow).forEach(r => localBody.appendChild(objToRow(r)));
  queueTableRefresh({ resetPage:true });
  refreshFieldSuggestions();
}
function readLocal(){ return Array.from(localBody.querySelectorAll("tr")).map(rowToObj).filter(r => Object.values(r).some(v => v !== "")); }
async function saveLocalToIDB(){
  const rows = readLocal().map(upgradeRow);
  await idbSet(IDB_KEY_ROWS, rows);
  await refreshDataStats();
  updateSuggestionDatalists(rows);
}
function addRow(data={}){
  localBody.appendChild(objToRow(upgradeRow(data)));
  queueTableRefresh();
  saveLocalToIDB().then(()=>{
    updateLastSaved();
  });
}
function asMetaText(meta){
  if(meta === undefined || meta === null) return "";
  if(typeof meta === "string") return meta;
  try { return JSON.stringify(meta); } catch { return String(meta); }
}
function parseMeta(metaText){
  const raw = asMetaText(metaText).trim();
  if(!raw) return {};
  try {
    const parsed = JSON.parse(raw);
    if(parsed && typeof parsed === "object") return parsed;
    return { value: parsed };
  } catch {
    return { previousMeta: raw };
  }
}
function toNoteArray(notes){
  if(notes === undefined || notes === null) return [];
  const source = Array.isArray(notes) ? notes : [notes];
  const out = [];
  for(const entry of source){
    if(entry === undefined || entry === null) continue;
    if(typeof entry === "object"){
      const copy = { ...entry };
      if(copy.note !== undefined) copy.note = String(copy.note ?? "");
      out.push(copy);
    } else {
      const text = String(entry);
      if(text.trim() === "") continue;
      out.push({ note: text });
    }
  }
  return out.filter(item => (item.note ?? "").toString().trim() !== "" || item.date !== undefined);
}
function fieldLabel(key){
  return key.split('_').map(part => part ? part[0].toUpperCase() + part.slice(1) : '').join(' ').replace(/Id/g, 'ID');
}
function normalizeViewValue(value){
  if(value === undefined || value === null) return '';
  if(typeof value === 'number'){
    const date = new Date(value);
    if(!Number.isNaN(date.getTime())){
      return date.toLocaleString();
    }
  }
  return String(value ?? '');
}
// Safely stringify meta data while filtering out duplicate fields.
function formatMetaForView(metaString){
  if(!metaString) return '';
  try {
    const parsed = typeof metaString === 'string' ? JSON.parse(metaString) : metaString;
    if(parsed === null) return '';
    if(Array.isArray(parsed)){
      return parsed.length ? JSON.stringify(parsed, null, 2) : '';
    }
    if(typeof parsed === 'object'){
      const filtered = {};
      let hasData = false;
      for(const [key, value] of Object.entries(parsed)){
        if(RESERVED_META_KEYS.has(normalizeFieldKey(key))) continue;
        filtered[key] = value;
        hasData = true;
      }
      return hasData ? JSON.stringify(filtered, null, 2) : '';
    }
    return JSON.stringify(parsed, null, 2);
  } catch {
    const text = String(metaString ?? '').trim();
    return text;
  }
}
function renderViewAsset(row){
  if(!row || !viewModalDetails) return;
  const base = rowToObj(row);
  const extras = parseMeta(base.meta);
  const record = { ...extras, ...base };
  viewModalDetails.innerHTML = '';
  VIEW_MODAL_FIELDS.forEach(field => {
    const value = field.aliases
      .map(alias => record[alias])
      .find(v => v !== undefined && v !== null && String(v).trim() !== '');
    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.scope = 'row';
    th.textContent = field.label;
    const td = document.createElement('td');
    td.textContent = normalizeViewValue(value ?? '');
    tr.appendChild(th);
    tr.appendChild(td);
    viewModalDetails.appendChild(tr);
  });
  const metaValueRaw = base.meta && base.meta.trim() ? formatMetaForView(base.meta.trim()) : '';
  if(metaValueRaw){
    const metaPreview = metaValueRaw.length > META_PREVIEW_LIMIT
      ? `${metaValueRaw.slice(0, META_PREVIEW_LIMIT).trimEnd()}…`
      : metaValueRaw;
    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.scope = 'row';
    th.textContent = 'Meta';
    const td = document.createElement('td');
    const wrapper = document.createElement('div');
    wrapper.className = 'd-flex flex-column gap-2';
    const pre = document.createElement('pre');
    pre.className = 'mb-0 meta-preview';
    pre.textContent = metaPreview;
    wrapper.appendChild(pre);
    if(metaValueRaw.length > META_PREVIEW_LIMIT){
      const hint = document.createElement('div');
      hint.className = 'small text-secondary';
      hint.textContent = 'Preview truncated. Open the meta viewer to see the full JSON.';
      wrapper.appendChild(hint);
    }
    const openBtn = document.createElement('button');
    openBtn.type = 'button';
    openBtn.className = 'btn btn-sm btn-outline-secondary align-self-start';
    openBtn.textContent = 'Open meta viewer';
    openBtn.addEventListener('click', ()=>{
      if(currentViewRow){
        handleViewMeta(currentViewRow);
      } else {
        handleViewMeta(row);
      }
    });
    wrapper.appendChild(openBtn);
    td.appendChild(wrapper);
    tr.appendChild(th);
    tr.appendChild(td);
    viewModalDetails.appendChild(tr);
  }
  if(viewModalTitle){
    const titleParts = [];
    const idPart = base.id ? `ID: ${base.id}` : (record.serial_number ? `Serial: ${record.serial_number}` : "");
    if(idPart) titleParts.push(idPart);
    if(record.assigned_to) titleParts.push(record.assigned_to);
    if(record.model) titleParts.push(record.model);
    viewModalTitle.textContent = titleParts.length ? titleParts.join(" • ") : 'Asset Details';
  }
}
function toggleViewEditMode(enabled){
  viewEditModeActive = !!enabled;
  if(viewModalReadOnly){
    viewModalReadOnly.classList.toggle("d-none", viewEditModeActive);
  }
  if(viewModalFormWrap){
    viewModalFormWrap.classList.toggle("d-none", !viewEditModeActive);
  }
  if(viewModalEditBtn){
    viewModalEditBtn.classList.toggle("d-none", viewEditModeActive);
  }
  if(viewModalCancelBtn){
    viewModalCancelBtn.classList.toggle("d-none", !viewEditModeActive);
  }
  if(viewModalSaveBtn){
    viewModalSaveBtn.classList.toggle("d-none", !viewEditModeActive);
  }
  if(viewEditModeActive){
    const target = viewFormInputs.serial_number || viewFormInputs.asset_tag;
    if(target){
      setTimeout(()=> target.focus(), 120);
    }
  }
}
function populateViewForm(row){
  if(!row) return;
  const data = rowToObj(row);
  if(viewFormInputs.serial_number) viewFormInputs.serial_number.value = data.serial_number ?? "";
  if(viewFormInputs.asset_tag) viewFormInputs.asset_tag.value = data.asset_tag ?? "";
  if(viewFormInputs.type) viewFormInputs.type.value = data.type ?? "";
  if(viewFormInputs.model) viewFormInputs.model.value = data.model ?? "";
  if(viewFormInputs.room) viewFormInputs.room.value = data.room ?? "";
  if(viewFormInputs.assigned_to) viewFormInputs.assigned_to.value = data.assigned_to ?? "";
  if(viewFormInputs.meta){
    const metaText = formatMetaForView(data.meta ?? "");
    viewFormInputs.meta.value = metaText;
  }
  const statusValue = data.status ?? "";
  if(viewModalStatusSelect){
    let matched = false;
    Array.from(viewModalStatusSelect.options || []).forEach(opt => {
      if(opt.value === statusValue){
        matched = true;
      }
    });
    viewModalStatusSelect.value = matched ? statusValue : "";
    if(viewModalStatusCustom){
      viewModalStatusCustom.value = matched ? "" : statusValue;
    }
  } else if(viewModalStatusCustom){
    viewModalStatusCustom.value = statusValue;
  }
}
function getFormStatusValue(){
  return norm(viewModalStatusSelect?.value) || norm(viewModalStatusCustom?.value);
}
async function applyViewFormChanges(){
  if(!currentViewRow) return;
  const serialValue = norm(viewFormInputs.serial_number?.value);
  const assetValue = norm(viewFormInputs.asset_tag?.value);
  const existingId = norm(currentViewRow.dataset?.id);
  const idValue = serialValue || assetValue || existingId;
  if(!idValue){
    alert("Provide at least a serial number or asset tag.");
    if(viewFormInputs.serial_number){
      viewFormInputs.serial_number.focus();
    } else if(viewFormInputs.asset_tag){
      viewFormInputs.asset_tag.focus();
    }
    return;
  }
  const updates = {
    id: idValue,
    serial_number: serialValue,
    asset_tag: assetValue,
    type: norm(viewFormInputs.type?.value),
    model: norm(viewFormInputs.model?.value),
    room: norm(viewFormInputs.room?.value),
    assigned_to: norm(viewFormInputs.assigned_to?.value),
    status: getFormStatusValue(),
    meta: viewFormInputs.meta?.value?.trim() ?? ""
  };
  for(const key of localCols){
    const cell = currentViewRow.querySelector(`td[data-k="${key}"]`);
    if(!cell) continue;
    if(key === "meta"){
      cell.textContent = updates.meta;
    } else if(key === "status"){
      cell.textContent = updates.status;
    } else {
      cell.textContent = updates[key] ?? "";
    }
  }
  if(updates.id){
    currentViewRow.dataset.id = updates.id;
  } else {
    delete currentViewRow.dataset.id;
  }
  updateMetaButtonState(currentViewRow);
  updateNoteButtonState(currentViewRow);
  renderViewAsset(currentViewRow);
  populateViewForm(currentViewRow);
  queueTableRefresh();
  if(viewModalSaveBtn) viewModalSaveBtn.disabled = true;
  try {
    await saveLocalToIDB();
    showSavedToast();
    updateLastSaved();
    const label = updates.serial_number
      ? `Serial ${updates.serial_number}`
      : (updates.asset_tag ? `Asset tag ${updates.asset_tag}` : (updates.id ? `Record ${updates.id}` : "Record"));
    setStatus("localImportStatus", `${label} updated.`, "success");
    toggleViewEditMode(false);
  } catch(err){
    setStatus("localImportStatus", `Failed to save changes: ${err.message}`, "error");
  } finally {
    if(viewModalSaveBtn) viewModalSaveBtn.disabled = false;
  }
}
function resetViewModalState(){
  currentViewRow = null;
  toggleViewEditMode(false);
}
function openViewAsset(row, options){
  if(!row) return;
  const { edit = false } = options || {};
  if(!viewModalEl || !viewModalDetails){
    alert('Asset details modal is unavailable in this environment.');
    return;
  }
  currentViewRow = row;
  renderViewAsset(row);
  populateViewForm(row);
  toggleViewEditMode(!!edit);
  if(viewModalInstance){
    viewModalInstance.show();
  } else {
    viewModalEl.classList.add('show');
    viewModalEl.style.display = 'block';
  }
}
if(viewModalEl && !viewModalInstance){
  // Provide manual hide handling when Bootstrap JS isn't available.
  const hideFallbackModal = ()=>{
    viewModalEl.classList.remove('show');
    viewModalEl.style.display = 'none';
    resetViewModalState();
  };
  const closeButtons = viewModalEl.querySelectorAll('[data-bs-dismiss="modal"]');
  closeButtons.forEach(btn => {
    btn.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      hideFallbackModal();
    });
  });
  viewModalEl.addEventListener('click', ev => {
    if(ev.target === viewModalEl){
      hideFallbackModal();
    }
  });
  viewModalEl.addEventListener('keydown', ev => {
    if(ev.key === 'Escape'){
      hideFallbackModal();
    }
  });
}
if(viewModalEl && viewModalInstance){
  viewModalEl.addEventListener('hidden.bs.modal', resetViewModalState);
}
if(viewModalEditBtn){
  viewModalEditBtn.addEventListener("click", ()=>{
    if(!currentViewRow) return;
    populateViewForm(currentViewRow);
    toggleViewEditMode(true);
  });
}
if(viewModalCancelBtn){
  viewModalCancelBtn.addEventListener("click", ()=>{
    if(currentViewRow) populateViewForm(currentViewRow);
    toggleViewEditMode(false);
  });
}
if(viewModalForm){
  viewModalForm.addEventListener("submit", ev => {
    ev.preventDefault();
    applyViewFormChanges();
  });
}
if(viewModalStatusSelect){
  viewModalStatusSelect.addEventListener("change", ()=>{
    if(viewModalStatusCustom && viewModalStatusSelect.value){
      viewModalStatusCustom.value = "";
    }
  });
}
if(viewModalStatusCustom){
  viewModalStatusCustom.addEventListener("input", ()=>{
    if(viewModalStatusSelect && viewModalStatusCustom.value.trim().length){
      viewModalStatusSelect.value = "";
    }
  });
}
function formatNoteTimestamp(value){
  if(value === undefined || value === null || value === ""){
    return "No date provided";
  }
  let date = new Date(value);
  if(Number.isNaN(date.getTime())){
    const num = Number(value);
    if(!Number.isNaN(num)){
      date = new Date(num);
    }
  }
  if(Number.isNaN(date.getTime())){
    return String(value);
  }
  return date.toLocaleString();
}
function updateNoteButtonState(tr){
  const metaCell = tr.querySelector('td[data-k="meta"]');
  const viewBtn = tr.querySelector(".view-note-btn");
  if(!metaCell || !viewBtn) return;
  const notes = toNoteArray(parseMeta(metaCell.textContent).notes);
  const count = notes.length;
  viewBtn.textContent = count ? `Notes (${count})` : "Notes";
  viewBtn.classList.toggle("btn-secondary", count > 0);
  viewBtn.classList.toggle("btn-outline-secondary", count === 0);
  viewBtn.title = count ? `${count} note${count===1?"":"s"}` : "No notes yet";
}
function updateMetaButtonState(tr){
  const metaCell = tr.querySelector('td[data-k="meta"]');
  const metaBtn = tr.querySelector(".view-meta-btn");
  if(!metaCell || !metaBtn) return;
  const hasMeta = metaCell.textContent.trim().length > 0;
  metaBtn.classList.toggle("btn-secondary", hasMeta);
  metaBtn.classList.toggle("btn-outline-secondary", !hasMeta);
  metaBtn.textContent = hasMeta ? "Meta •" : "Meta";
  metaBtn.title = hasMeta ? metaCell.textContent : "No meta stored";
}
let currentNoteRow = null;
let currentMetaRow = null;
function handleAddNote(tr){
  currentNoteRow = tr;
  const idCell = tr.querySelector('td[data-k="id"]');
  const assetId = idCell?.textContent.trim() || "(no id)";
  if(window.bootstrap && noteModalEl){
    if(noteModalTitle) noteModalTitle.textContent = `Add Note – ${assetId}`;
    if(noteTextEl) noteTextEl.value = "";
    const modal = bootstrap.Modal.getOrCreateInstance(noteModalEl);
    modal.show();
    setTimeout(()=> noteTextEl?.focus(), 120);
  } else if(noteFallbackEl){
    if(noteFallbackTitle) noteFallbackTitle.innerHTML = `<strong>Add Note – ${escapeHtml(assetId)}</strong>`;
    if(noteFallbackText) noteFallbackText.value = "";
    noteFallbackEl.classList.add('show');
    setTimeout(()=> noteFallbackText?.focus(), 50);
  } else {
    setStatus("localImportStatus", "Note entry UI unavailable in this environment.", "error");
  }
}
function commitNote(noteTextRaw){
  const tr = currentNoteRow;
  if(!tr){
    setStatus("localImportStatus", "No row selected for note.", "error");
    return false;
  }
  const noteText = noteTextRaw.trim();
  if(noteText === ""){
    setStatus("localImportStatus", "Empty note discarded.", "info");
    return false;
  }
  const metaCell = tr.querySelector('td[data-k="meta"]');
  if(!metaCell){
    setStatus("localImportStatus", "Unable to locate meta field for this row.", "error");
    return false;
  }
  const metaObj = parseMeta(metaCell.textContent);
  const entry = { date: Date.now(), note: noteText };
  if(metaObj.notes === undefined){
    metaObj.notes = entry;
  } else if(Array.isArray(metaObj.notes)){
    metaObj.notes.push(entry);
  } else {
    metaObj.notes = [metaObj.notes, entry];
  }
  metaCell.textContent = JSON.stringify(metaObj);
  updateNoteButtonState(tr);
  updateMetaButtonState(tr);
  saveLocalToIDB().then(()=>{
    showSavedToast();
    const ts = new Date(entry.date).toLocaleString();
    setStatus("localImportStatus", `Note added (${ts}).`, "success");
    queueTableRefresh();
    currentNoteRow = null;
  }).catch(err=>{
    setStatus("localImportStatus", `Failed to save note: ${err.message}`, "error");
  });
  return true;
}
function handleViewMeta(tr){
  currentMetaRow = tr;
  const idCell = tr.querySelector('td[data-k="id"]');
  const metaCell = tr.querySelector('td[data-k="meta"]');
  if(!metaCell){
    setStatus("localImportStatus", "Unable to locate meta field for this row.", "error");
    return;
  }
  const assetId = idCell?.textContent.trim() || "(no id)";
  const rawMeta = metaCell.textContent ?? "";
  const filteredMeta = formatMetaForView(rawMeta);
  const prettyMeta = filteredMeta || (()=> {
    if(!rawMeta) return "";
    try { return JSON.stringify(JSON.parse(rawMeta), null, 2); }
    catch { return rawMeta; }
  })();
  if(window.bootstrap && metaModalEl){
    if(metaModalTitle) metaModalTitle.textContent = `Meta – ${assetId}`;
    if(metaModalText) metaModalText.value = prettyMeta;
    const modal = bootstrap.Modal.getOrCreateInstance(metaModalEl);
    modal.show();
    setTimeout(()=> metaModalText?.focus(), 120);
  } else if(metaFallbackEl){
    if(metaFallbackTitle) metaFallbackTitle.innerHTML = `<strong>Meta – ${escapeHtml(assetId)}</strong>`;
    if(metaFallbackText) metaFallbackText.value = prettyMeta;
    metaFallbackEl.classList.add('show');
    setTimeout(()=> metaFallbackText?.focus(), 50);
  } else {
    setStatus("localImportStatus", "Meta viewer unavailable in this environment.", "error");
  }
}
function commitMetaValue(valueRaw){
  const tr = currentMetaRow;
  if(!tr){
    setStatus("localImportStatus", "No row selected for meta.", "error");
    return false;
  }
  const metaCell = tr.querySelector('td[data-k="meta"]');
  if(!metaCell){
    setStatus("localImportStatus", "Unable to locate meta field for this row.", "error");
    return false;
  }
  const metaValue = typeof valueRaw === "string" ? valueRaw.trim() : "";
  metaCell.textContent = metaValue;
  updateMetaButtonState(tr);
  updateNoteButtonState(tr);
  queueTableRefresh();
  saveLocalToIDB().then(()=>{
    showSavedToast();
    const message = metaValue ? "Meta updated." : "Meta cleared.";
    setStatus("localImportStatus", message, "success");
    currentMetaRow = null;
  }).catch(err=>{
    setStatus("localImportStatus", `Failed to save meta: ${err.message}`, "error");
  });
  return true;
}
function handleViewNotes(tr){
  const idCell = tr.querySelector('td[data-k="id"]');
  const metaCell = tr.querySelector('td[data-k="meta"]');
  if(!metaCell){
    setStatus("localImportStatus", "Unable to locate meta field for this row.", "error");
    return;
  }
  const assetId = idCell?.textContent.trim() || "(no id)";
  const rawMeta = metaCell.textContent ?? "";
  const parsedMeta = parseMeta(rawMeta);
  const notes = toNoteArray(parsedMeta.notes);
  const listHtml = notes.length
    ? `<ol class="mb-0">${notes.map(entry=>{
        const timestamp = formatNoteTimestamp(entry.date);
        const noteText = (entry.note ?? "").toString();
        const formattedNote = noteText
          ? escapeHtml(noteText).replace(/\n/g,"<br>")
          : '<span class="text-secondary fst-italic">No note text</span>';
        const extrasKeys = Object.keys(entry).filter(k => k !== "note" && k !== "date");
        const extras = extrasKeys.length
          ? `<div class="small text-secondary">${extrasKeys.map(k => `${escapeHtml(k)}: ${escapeHtml(String(entry[k]))}`).join(", ")}</div>`
          : "";
        return `<li><time>${escapeHtml(timestamp)}</time><div>${formattedNote}</div>${extras}</li>`;
      }).join("")}</ol>`
    : '<p class="text-secondary mb-0">No notes recorded yet.</p>';
  const filteredNotesMeta = formatMetaForView(rawMeta);
  let metaLabel = "Meta JSON";
  let prettyMeta = filteredNotesMeta || rawMeta.trim();
  if(prettyMeta){
    try {
      prettyMeta = JSON.stringify(JSON.parse(prettyMeta), null, 2);
    } catch {
      prettyMeta = prettyMeta.trim();
    }
  } else {
    prettyMeta = "(empty)";
  }
  if(!filteredNotesMeta && rawMeta.trim()){
    metaLabel = "Meta (raw)";
  }
  if(window.bootstrap && notesModalEl){
    if(notesTitleEl) notesTitleEl.textContent = `Notes – ${assetId}`;
    if(notesListEl) notesListEl.innerHTML = listHtml;
    if(notesMetaLabelEl) notesMetaLabelEl.textContent = metaLabel;
    if(notesMetaEl) notesMetaEl.textContent = prettyMeta;
    const modal = bootstrap.Modal.getOrCreateInstance(notesModalEl);
    modal.show();
  } else if(notesFallbackEl){
    if(notesFallbackTitle) notesFallbackTitle.innerHTML = `<strong>Notes – ${escapeHtml(assetId)}</strong>`;
    if(notesFallbackContent) notesFallbackContent.innerHTML = `${listHtml}<hr><div class="small text-secondary mb-1">${escapeHtml(metaLabel)}</div><pre class="notes-pre">${escapeHtml(prettyMeta)}</pre>`;
    notesFallbackEl.classList.add('show');
  } else {
    setStatus("localImportStatus", "Unable to display notes viewer.", "error");
  }
}
function normalizeSearchValue(value){
  return (value ?? "").toString().toLowerCase();
}
function compareValues(a, b, key){
  const vaRaw = a[key] ?? "";
  const vbRaw = b[key] ?? "";
  const vaStr = (vaRaw ?? "").toString().trim();
  const vbStr = (vbRaw ?? "").toString().trim();
  const na = Number(vaStr);
  const nb = Number(vbStr);
  const bothNumeric = !Number.isNaN(na) && !Number.isNaN(nb);
  if(bothNumeric){
    if(na < nb) return -1;
    if(na > nb) return 1;
    return 0;
  }
  return vaStr.localeCompare(vbStr, undefined, { sensitivity:"base", numeric:true });
}
function updateSortIndicators(){
  const ths = document.querySelectorAll('#localTable thead th[data-sort]');
  ths.forEach(th => {
    const key = th.dataset.sort;
    const indicator = th.querySelector('.sort-indicator');
    const isActive = key === tableState.sortBy;
    th.classList.toggle('sorted', isActive);
    const dir = isActive ? tableState.sortDir : "none";
    th.setAttribute("aria-sort", dir === "none" ? "none" : (dir === "asc" ? "ascending" : "descending"));
    if(indicator){
      let symbol = "↕";
      if(isActive){
        symbol = tableState.sortDir === "asc" ? "▲" : "▼";
      }
      indicator.textContent = symbol;
    }
  });
}
function updateStatusFilterOptions(source){
  if(!localStatusFilter) return;
  const arr = Array.isArray(source) ? source : [];
  const deduped = Array.from(new Set(arr.filter(Boolean).map(v => v.toString())));
  const current = localStatusFilter.value;
  const options = ['<option value="">All statuses</option>', ...deduped.sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"})).map(val => `<option value="${escapeHtml(val)}">${escapeHtml(val)}</option>`)];
  localStatusFilter.innerHTML = options.join("");
  if(deduped.includes(current)){
    localStatusFilter.value = current;
  } else {
    localStatusFilter.value = "";
    tableState.status = "";
  }
}
function syncStatusFilterOptions(){
  if(!localStatusFilter) return;
  const rows = Array.from(localBody.querySelectorAll("tr"));
  const statuses = new Set();
  rows.forEach(row => {
    const obj = rowToObj(row);
    if(obj.status) statuses.add(obj.status);
  });
  updateStatusFilterOptions(Array.from(statuses));
}
function resetLocalFilters(){
  tableState.search = "";
  tableState.status = "";
  tableState.page = 1;
  if(localSearchInput) localSearchInput.value = "";
  if(localStatusFilter) localStatusFilter.value = "";
}
function findRowBySerial(serialValue){
  const normalized = (serialValue ?? "").toString().trim().toLowerCase();
  if(!normalized) return null;
  const rows = Array.from(localBody.querySelectorAll("tr"));
  for(const row of rows){
    const obj = rowToObj(row);
    const serial = (obj.serial_number ?? "").toString().trim().toLowerCase();
    if(serial && serial === normalized){
      return row;
    }
  }
  return null;
}
async function markRowVerified(row){
  if(!row) return false;
  const metaCell = row.querySelector('td[data-k="meta"]');
  if(!metaCell) return false;
  const metaObj = parseMeta(metaCell.textContent);
  metaObj.last_verified_date = new Date().toISOString();
  metaCell.textContent = JSON.stringify(metaObj);
  updateMetaButtonState(row);
  updateNoteButtonState(row);
  await saveLocalToIDB();
  updateLastSaved();
  return true;
}
async function refreshDataStats(){
  if(!dataStatsEl) return;
  try {
    const [rowsValue, statusesValue] = await Promise.all([
      idbGet(IDB_KEY_ROWS).catch(()=>undefined),
      idbGet(IDB_KEY_STATUS).catch(()=>undefined)
    ]);
    const rowsList = Array.isArray(rowsValue) ? rowsValue : [];
    const statusesList = Array.isArray(statusesValue) ? statusesValue : [];
    const totalBytes = estimateSize(rowsList) + estimateSize(statusesList);
    let verifiedCount = 0;
    for(const row of rowsList){
      const metaObj = parseMeta(row?.meta);
      if(metaObj && metaObj.last_verified_date){
        verifiedCount++;
      }
    }
    const message = `Rows: ${rowsList.length} (verified ${verifiedCount}), Status options: ${statusesList.length}, Approx size: ${formatBytes(totalBytes)}.`;
    dataStatsEl.textContent = message;
  } catch(err){
    dataStatsEl.textContent = `Unable to read storage stats (${err.message})`;
  }
}
function wipeIndexedDB(){
  return new Promise((resolve, reject)=>{
    let blocked = false;
    try {
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onblocked = ()=> {
        blocked = true;
        reject(new Error("Deletion blocked. Close other tabs using this inventory."));
      };
      req.onerror = ()=> reject(req.error || new Error("Failed to delete IndexedDB."));
      req.onsuccess = ()=> {
        if(!blocked) resolve();
      };
    } catch(err){
      reject(err);
    }
  });
}
function refreshLocalView(opts){
  opts = opts || {};
  if(opts.resetPage){ tableState.page = 1; }
  if(opts.search !== undefined){ tableState.search = opts.search; }
  if(opts.status !== undefined){ tableState.status = opts.status; }
  if(opts.pageSize !== undefined){ tableState.pageSize = opts.pageSize; }
  if(opts.sortBy !== undefined && SORTABLE_COLS.has(opts.sortBy)){
    if(tableState.sortBy !== opts.sortBy){
      tableState.sortBy = opts.sortBy;
    }
  }
  if(opts.sortDir !== undefined){
    tableState.sortDir = opts.sortDir === "desc" ? "desc" : "asc";
  }
  if(opts.page !== undefined){
    tableState.page = Math.max(1, Number(opts.page) || 1);
  }
  const rows = Array.from(localBody.querySelectorAll("tr"));
  syncStatusFilterOptions();
  const searchTerm = normalizeSearchValue(tableState.search).trim();
  const statusFilterValue = tableState.status;
  const filtered = [];
  rows.forEach(row => {
    const data = rowToObj(row);
    const values = Object.values(data).map(v => normalizeSearchValue(v));
    const matchesSearch = searchTerm ? values.some(val => val.includes(searchTerm)) : true;
    const matchesStatus = statusFilterValue ? normalizeSearchValue(data.status) === normalizeSearchValue(statusFilterValue) : true;
    if(matchesSearch && matchesStatus){
      filtered.push({ row, data });
    } else {
      row.style.display = "none";
    }
  });
  const sortKey = SORTABLE_COLS.has(tableState.sortBy) ? tableState.sortBy : "serial_number";
  filtered.sort((a,b)=>{
    const cmp = compareValues(a.data, b.data, sortKey);
    return tableState.sortDir === "desc" ? -cmp : cmp;
  });
  filtered.forEach(item => localBody.appendChild(item.row));
  const totalRows = rows.length;
  const totalFiltered = filtered.length;
  const pageSizeRaw = tableState.pageSize;
  const pageSize = pageSizeRaw === "all" ? 0 : Math.max(1, Number(pageSizeRaw) || 25);
  const totalPages = pageSize === 0 ? 1 : Math.max(1, Math.ceil(totalFiltered / pageSize));
  tableState.page = Math.min(Math.max(1, tableState.page), totalPages);
  const startIndex = pageSize === 0 ? 0 : (tableState.page - 1) * pageSize;
  const endIndex = pageSize === 0 ? totalFiltered : Math.min(startIndex + pageSize, totalFiltered);
  filtered.forEach((item, idx)=>{
    const visible = pageSize === 0 || (idx >= startIndex && idx < endIndex);
    item.row.style.display = visible ? "" : "none";
  });
  if(localFilterStatus){
    if(totalFiltered === 0){
      localFilterStatus.textContent = totalRows === 0
        ? "No rows in the working set yet."
        : "No rows match your current filters.";
    } else {
      const displayStart = pageSize === 0 ? 1 : startIndex + 1;
      const displayEnd = pageSize === 0 ? totalFiltered : endIndex;
      const info = `${displayStart}–${displayEnd} of ${totalFiltered} matching row${totalFiltered===1?"":"s"} (${totalRows} total)`;
      localFilterStatus.textContent = info;
    }
  }
  const prevDisabled = tableState.page <= 1;
  const nextDisabled = tableState.page >= totalPages;
  if(localPrevPage){ localPrevPage.disabled = prevDisabled; }
  if(localNextPage){ localNextPage.disabled = nextDisabled; }
  if(localPaginationInfo){
    if(totalFiltered === 0){
      localPaginationInfo.textContent = "";
    } else if(pageSize === 0){
      localPaginationInfo.textContent = `Showing all ${totalFiltered} row${totalFiltered===1?"":"s"}.`;
    } else {
      localPaginationInfo.textContent = `Page ${tableState.page} of ${totalPages}`;
    }
  }
  if(localPaginationBar){
    const hidePagination = totalFiltered <= (pageSize === 0 ? Infinity : pageSize);
    localPaginationBar.classList.toggle("vis-hide", hidePagination);
  }
  updateSortIndicators();
}
function deleteSelected(){
  $$(".selRow:checked").forEach(cb => cb.closest("tr").remove());
  queueTableRefresh();
  saveLocalToIDB().then(()=>{ updateLastSaved(); });
}
selAll.addEventListener("change", e => { $$(".selRow").forEach(cb => cb.checked = selAll.checked); });

// ======= Status options =======
const statusInput = $("#statusOptions"); const statusSaved = $("#statusSaved");
$("#saveStatus").addEventListener("click", async ()=>{
  const raw = statusInput.value; const arr = raw.split(",").map(s => s.trim()).filter(Boolean);
  await idbSet(IDB_KEY_STATUS, arr);
  statusSaved.textContent = `Saved ${arr.length} item(s)`; populateStatusSelect(arr); showSavedToast();
  await refreshDataStats();
});
function populateStatusSelect(arr){
  const list = Array.isArray(arr) ? arr : [];
  const applyOptions = (selectEl)=>{
    if(!selectEl) return;
    selectEl.innerHTML = "";
    const blankOpt = document.createElement("option");
    blankOpt.value = "";
    blankOpt.textContent = "(none)";
    selectEl.appendChild(blankOpt);
    for(const s of list){
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s;
      selectEl.appendChild(opt);
    }
  };
  applyOptions(document.getElementById("m_status"));
  applyOptions(viewModalStatusSelect);
  const fbSel = document.getElementById("fb_status");
  if(fbSel){
    const options = ['<option value="">(none)</option>', ...list.map(s => `<option>${escapeHtml(s)}</option>`)];
    fbSel.innerHTML = options.join("");
  }
  updateStatusFilterOptions(list);
  queueTableRefresh();
  if(currentViewRow){
    populateViewForm(currentViewRow);
  }
}
// ======= Official snapshot =======
let officialRows = []; const officialStats = $("#officialStats");
const officialPreviewWrap = $("#officialPreviewWrap"); const officialPreviewHead = $("#officialPreview thead"); const officialPreviewBody = $("#officialPreview tbody");
function loadOfficialCSVObjects(rows, opts){
  officialRows = rows;
  const statsLabel = opts?.statsLabel ?? `${rows.length} row(s) ready`;
  officialStats.textContent = statsLabel;
  officialPreviewHead.innerHTML = "";
  officialPreviewBody.innerHTML = "";
  officialPreviewWrap.textContent = "";
  officialPreviewWrap.classList.add("vis-hide");
}
function clearOfficial(){
  officialRows = [];
  officialStats.textContent = "No file loaded";
  officialPreviewWrap.classList.add("vis-hide");
  officialPreviewHead.innerHTML="";
  officialPreviewBody.innerHTML="";
  setStatus("officialImportStatus", "Official snapshot cleared.", "info");
}

// ======= Diff logic =======
function diffInventories(localRows, officialRows, opts){
  const { emptyClears=false, ignoreMeta=false } = opts || {};
  const baseFields = ["serial_number","asset_tag","type","model","room","assigned_to","status","meta"];
  const fields = baseFields.filter(f => !(ignoreMeta && f==="meta"));
  const local = toMapById(localRows); const official = toMapById(officialRows);
  const tags = new Set([...local.keys(), ...official.keys()]); const changes = [];
  for(const id of tags){
    const L = local.get(id); const O = official.get(id);
    if(L && !O){ changes.push({Action:"ADD", Tag:id, Field:"(all)", OldValue:"", NewValue:JSON.stringify(L), Notes:""}); continue; }
    if(!L && O){ changes.push({Action:"REMOVE", Tag:id, Field:"(all)", OldValue:JSON.stringify(O), NewValue:"", Notes:"Not in local working set"}); continue; }
    for(const f of fields){
      const o = norm(O?.[f]); const l = norm(L?.[f]); const isEmptyNoOp = !emptyClears && l === ""; const changed = isEmptyNoOp ? false : (o !== l);
      if(changed){ changes.push({Action:"UPDATE", Tag:id, Field:f, OldValue:o, NewValue:l, Notes:""}); }
    }
  }
  return changes;
}
function renderDiff(rows){
  const tbody = $("#diffBody"); tbody.innerHTML = "";
  for(const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${r.Action}</td><td class="code">${r.Tag}</td><td>${r.Field}</td>
      <td class="code">${escapeHtml(r.OldValue)}</td>
      <td class="code">${escapeHtml(r.NewValue)}</td><td>${r.Notes??""}</td>`;
    tbody.appendChild(tr);
  }
  $("#diffStats").textContent = rows.length ? `${rows.length} change(s)` : "No differences";
  $("#downloadCsv").disabled = rows.length===0; $("#copyMd").disabled = rows.length===0;
}
function escapeHtml(s){ return String(s ?? "").replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }

// ======= Wire up =======
$("#deleteSelected").addEventListener("click", deleteSelected);

$("#saveLocalJson").addEventListener("click", ()=>{
  const rows = readLocal().map(upgradeRow); const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([JSON.stringify(rows, null, 2)], {type:"application/json"}));
  a.download = "local-working-set.json"; a.click();
});
$("#saveLocalCsv").addEventListener("click", ()=>{
  const rows = readLocal().map(upgradeRow); const cols = localCols; const head = cols.join(",");
  const esc = v => `"${String(v ?? '').replace(/"/g,'""')}"`;
  const lines = rows.map(r => cols.map(c => esc(r[c])).join(","));
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([[head, ...lines].join("\n")], {type:"text/csv"}));
  a.download = "local-working-set.csv"; a.click();
});

$("#loadLocalFile").addEventListener("change", async (e)=>{
  const f = e.target.files[0];
  if(!f){ setStatus("localImportStatus", "No file selected.", "info"); return; }
  setStatus("localImportStatus", `Reading "${f.name}"…`, "info");
  try{
    let text = await f.text();
    text = normalizeCSVText(text);
    let rows;
    if(f.name.toLowerCase().endsWith(".json")){
      rows = JSON.parse(text);
      if(!Array.isArray(rows)){
        const candidate = grab(rows || {}, "rows","data","items","inventory","Records","records");
        if(Array.isArray(candidate)){ rows = candidate; }
        else throw new Error("JSON must be an array or contain a top-level array (rows/items/data).");
      }
    } else {
      const parsed = parseCSV(text);
      rows = parsed.rows;
      if(rows.length === 0){ throw new Error("No data rows detected in CSV."); }
    }
    const total = rows.length;
    const upgraded = rows.map(upgradeRow);
    const valid = upgraded.filter(r => norm(r.id));
    const skipped = total - valid.length;
    renderLocal(valid);
    await saveLocalToIDB();
    if(valid.length === 0){
      setStatus("localImportStatus", "Import completed but no rows contained an \"id\" value.", "info");
    } else {
      const msg = [`Imported ${valid.length} row${valid.length===1?"":"s"}`];
      if(skipped > 0){ msg.push(`${skipped} skipped (missing id)`); }
      setStatus("localImportStatus", msg.join("; ") + ".", "success");
    }
  } catch(err){
    setStatus("localImportStatus", `Import failed: ${err.message}`, "error");
  } finally {
    e.target.value = "";
  }
});

$("#loadOfficialCsv").addEventListener("change", async (e)=>{
  const f = e.target.files[0];
  if(!f){ setStatus("officialImportStatus", "No file selected.", "info"); return; }
  setStatus("officialImportStatus", `Reading "${f.name}"…`, "info");
  try{
    let text = await f.text();
    text = normalizeCSVText(text);
    const { headers, rows } = parseCSV(text);
    if(headers.length===0) throw new Error("No headers found");
    const canonical = rows.map(r => {
      const o = {};
      for(const k of Object.keys(r)){
        const key = typeof k === "string" ? k.trim() : k;
        if(key) o[key] = r[k];
      }
      return o;
    });
    const upgraded = canonical.map(upgradeRow);
    const total = upgraded.length;
    if(total === 0){
      loadOfficialCSVObjects([], { statsLabel: "0 row(s) ready" });
      setStatus("officialImportStatus", "Import completed but the file contained no data rows.", "info");
      return;
    }
    const valid = upgraded.filter(r => norm(r.id));
    const skipped = total - valid.length;
    if(valid.length === 0){
      loadOfficialCSVObjects([], { statsLabel: "0 row(s) ready" });
      setStatus("officialImportStatus", "No rows contained an identifier (id/tag); nothing was loaded.", "error");
      return;
    }
    const statsLabel = `${valid.length} row${valid.length===1?"":"s"} ready${skipped>0?`, ${skipped} skipped`:""}`;
    loadOfficialCSVObjects(valid, { statsLabel });
    const msg = [`Loaded ${valid.length} row${valid.length===1?"":"s"} from "${f.name}"`];
    if(skipped > 0) msg.push(`${skipped} skipped (missing id)`);
    setStatus("officialImportStatus", msg.join("; ") + ".", skipped > 0 ? "info" : "success");
  } catch(err){
    setStatus("officialImportStatus", `Import failed: ${err.message}`, "error");
  } finally {
    e.target.value = "";
  }
});

$("#btnDiff").addEventListener("click", async ()=>{
  const local = readLocal().map(upgradeRow); if(local.some(r => !norm(r.id))) { alert("All rows must have a non-empty 'id'."); return; }
  const opts = { emptyClears: $("#emptyClears").checked, ignoreMeta: $("#ignoreMeta").checked };
  const diff = diffInventories(local, officialRows, opts); renderDiff(diff); window.__lastDiff = diff;
});
$("#downloadCsv").addEventListener("click", ()=>{
  const diff = window.__lastDiff || []; const csv = toCSV(diff);
  const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
  const a = document.createElement("a"); a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv"})); a.download = `inventory-changes-${ts}.csv`; a.click();
});
$("#copyMd").addEventListener("click", async ()=>{
  const diff = window.__lastDiff || []; const md = toMarkdown(diff);
  try { await navigator.clipboard.writeText(md); alert("Markdown copied to clipboard."); } catch { alert("Copy failed—your browser may block clipboard access."); }
});

// ======= Add Modal (Bootstrap or fallback) =======
const openAdd = document.getElementById('openAdd');
const confirmAdd = document.getElementById('confirmAdd');
const addModalEl = document.getElementById('addModal');
const fbModalEl = document.getElementById('fallbackModal');

const m_serial_number = document.getElementById('m_serial_number');
const m_asset_tag = document.getElementById('m_asset_tag');
const m_type = document.getElementById('m_type');
const m_model = document.getElementById('m_model');
const m_room = document.getElementById('m_room');
const m_assigned_to = document.getElementById('m_assigned_to');
const m_status = document.getElementById('m_status');
const m_status_custom = document.getElementById('m_status_custom');
const m_meta = document.getElementById('m_meta');

const fb_serial_number = document.getElementById('fb_serial_number');
const fb_asset_tag = document.getElementById('fb_asset_tag');
const fb_type = document.getElementById('fb_type');
const fb_model = document.getElementById('fb_model');
const fb_room = document.getElementById('fb_room');
const fb_assigned_to = document.getElementById('fb_assigned_to');
const fb_status = document.getElementById('fb_status');
const fb_status_custom = document.getElementById('fb_status_custom');
const fb_meta = document.getElementById('fb_meta');
const fb_cancel = document.getElementById('fb_cancel');
const fb_confirm = document.getElementById('fb_confirm');
const localSearchInput = document.getElementById('localSearch');
const localStatusFilter = document.getElementById('localStatusFilter');
const localPageSizeSelect = document.getElementById('localPageSize');
const localFilterStatus = document.getElementById('localFilterStatus');
const localPaginationInfo = document.getElementById('localPaginationInfo');
const localPaginationBar = document.getElementById('localPaginationBar');
const localPrevPage = document.getElementById('localPrevPage');
const localNextPage = document.getElementById('localNextPage');
const notesModalEl = document.getElementById('notesModal');
const notesTitleEl = document.getElementById('notesTitle');
const notesListEl = document.getElementById('notesList');
const notesMetaLabelEl = document.getElementById('notesMetaLabel');
const notesMetaEl = document.getElementById('notesMetaJson');
const noteModalEl = document.getElementById('noteModal');
const noteModalTitle = document.getElementById('noteModalTitle');
const noteTextEl = document.getElementById('noteText');
const noteModalSaveBtn = document.getElementById('noteModalSave');
const metaModalEl = document.getElementById('metaModal');
const metaModalTitle = document.getElementById('metaModalTitle');
const metaModalText = document.getElementById('metaModalText');
const metaModalSaveBtn = document.getElementById('metaModalSave');
const dataStatsEl = document.getElementById('dataStats');
const clearIndexedDBBtn = document.getElementById('clearIndexedDB');
const notesFallbackEl = document.getElementById('notesFallback');
const notesFallbackTitle = document.getElementById('notesFallbackTitle');
const notesFallbackContent = document.getElementById('notesFallbackContent');
const notesFallbackClose = document.getElementById('notesFallbackClose');
const noteFallbackEl = document.getElementById('noteFallback');
const noteFallbackTitle = document.getElementById('noteFallbackTitle');
const noteFallbackText = document.getElementById('noteFallbackText');
const noteFallbackCancel = document.getElementById('noteFallbackCancel');
const noteFallbackSave = document.getElementById('noteFallbackSave');
const metaFallbackEl = document.getElementById('metaFallback');
const metaFallbackTitle = document.getElementById('metaFallbackTitle');
const metaFallbackText = document.getElementById('metaFallbackText');
const metaFallbackCancel = document.getElementById('metaFallbackCancel');
const metaFallbackSave = document.getElementById('metaFallbackSave');
const seedSampleBtn = document.getElementById('seedSample');
const seedConfirmModalEl = document.getElementById('seedConfirmModal');
const seedConfirmConfirm = document.getElementById('seedConfirmConfirm');
const seedConfirmCancel = document.getElementById('seedConfirmCancel');
const seedConfirmFallbackEl = document.getElementById('seedConfirmFallback');
const seedConfirmFallbackConfirm = document.getElementById('seedConfirmFallbackConfirm');
const seedConfirmFallbackCancel = document.getElementById('seedConfirmFallbackCancel');

if(clearIndexedDBBtn){
  clearIndexedDBBtn.addEventListener("click", async ()=>{
    const confirmed = window.confirm("Delete all cached inventory data in this browser?");
    if(!confirmed){
      setStatus("dataStatus", "Deletion cancelled.", "info");
      return;
    }
    clearIndexedDBBtn.disabled = true;
    setStatus("dataStatus", "Deleting stored data…", "info");
    try {
      await wipeIndexedDB();
      localStorage.removeItem(LS_KEY_MIGRATION);
      if(statusInput) statusInput.value = "";
      if(statusSaved) statusSaved.textContent = "Not saved";
      populateStatusSelect([]);
      if(selAll) selAll.checked = false;
      if(localBody) localBody.innerHTML = "";
      resetLocalFilters();
      queueTableRefresh({ resetPage:true });
      setStatus("localImportStatus", "Local table cleared. Seed sample data or import to continue.", "info");
      setStatus("dataStatus", "Stored data deleted. Reload or seed sample data to continue.", "success");
      showSavedToast("Stored data deleted.", "dataStatus");
    } catch(err){
      setStatus("dataStatus", `Failed to delete stored data: ${err.message}`, "error");
    } finally {
      clearIndexedDBBtn.disabled = false;
      await refreshDataStats();
    }
  });
}

if(noteModalSaveBtn && noteModalEl){
  noteModalSaveBtn.addEventListener("click", ()=>{
    if(commitNote(noteTextEl.value)){
      if(window.bootstrap){
        const inst = bootstrap.Modal.getInstance(noteModalEl);
        inst?.hide();
      }
      if(noteTextEl) noteTextEl.value = "";
    }
  });
  noteModalEl.addEventListener("shown.bs.modal", ()=> noteTextEl?.focus());
  noteModalEl.addEventListener("hidden.bs.modal", ()=>{
    currentNoteRow = null;
    if(noteTextEl) noteTextEl.value = "";
  });
}
if(metaModalSaveBtn && metaModalEl){
  metaModalSaveBtn.addEventListener("click", ()=>{
    if(commitMetaValue(metaModalText.value)){
      if(window.bootstrap){
        const inst = bootstrap.Modal.getInstance(metaModalEl);
        inst?.hide();
      }
      if(metaModalText) metaModalText.value = "";
    }
  });
  metaModalEl.addEventListener("shown.bs.modal", ()=> metaModalText?.focus());
  metaModalEl.addEventListener("hidden.bs.modal", ()=>{
    currentMetaRow = null;
    if(metaModalText) metaModalText.value = "";
  });
}
if(noteFallbackCancel && noteFallbackEl){
  noteFallbackCancel.addEventListener("click", ()=>{
    noteFallbackEl.classList.remove('show');
    currentNoteRow = null;
    if(noteFallbackText) noteFallbackText.value = "";
  });
}
if(noteFallbackSave && noteFallbackEl){
  noteFallbackSave.addEventListener("click", ()=>{
    if(commitNote(noteFallbackText.value)){
      noteFallbackEl.classList.remove('show');
      currentNoteRow = null;
      if(noteFallbackText) noteFallbackText.value = "";
    }
  });
}
if(noteFallbackEl){
  noteFallbackEl.addEventListener("click", ev => {
    if(ev.target === noteFallbackEl){
      noteFallbackEl.classList.remove('show');
      currentNoteRow = null;
      if(noteFallbackText) noteFallbackText.value = "";
    }
  });
}
if(metaFallbackCancel && metaFallbackEl){
  metaFallbackCancel.addEventListener("click", ()=>{
    metaFallbackEl.classList.remove('show');
    currentMetaRow = null;
    if(metaFallbackText) metaFallbackText.value = "";
  });
}
if(metaFallbackSave && metaFallbackEl){
  metaFallbackSave.addEventListener("click", ()=>{
    if(commitMetaValue(metaFallbackText.value)){
      metaFallbackEl.classList.remove('show');
      currentMetaRow = null;
      if(metaFallbackText) metaFallbackText.value = "";
    }
  });
}
if(metaFallbackEl){
  metaFallbackEl.addEventListener("click", ev => {
    if(ev.target === metaFallbackEl){
      metaFallbackEl.classList.remove('show');
      currentMetaRow = null;
      if(metaFallbackText) metaFallbackText.value = "";
    }
  });
}
let seedSampleInFlight = false;
async function performSeedSample(){
  if(seedSampleInFlight) return;
  seedSampleInFlight = true;
  if(seedSampleBtn) seedSampleBtn.disabled = true;
  setStatus("localImportStatus", "Seeding sample data…", "info");
  setStatus("seedSampleStatus", "Seeding sample data…", "info");
  try {
    const sampleRows = createSeedRows(100).map(upgradeRow);
    resetLocalFilters();
    renderLocal(sampleRows);
    queueTableRefresh({ resetPage:true });
    if(selAll) selAll.checked = false;
    await saveLocalToIDB();
    updateLastSaved();
    const successMsg = "Sample data populated (100 rows).";
    setStatus("localImportStatus", successMsg, "success");
    setStatus("seedSampleStatus", successMsg, "success");
    showSavedToast(successMsg, "localImportStatus");
    await refreshDataStats();
  } catch(err){
    console.error("Seed sample data failed", err);
    setStatus("localImportStatus", `Failed to seed sample data: ${err.message}`, "error");
    setStatus("seedSampleStatus", `Failed to seed sample data: ${err.message}`, "error");
  } finally {
    seedSampleInFlight = false;
    if(seedSampleBtn) seedSampleBtn.disabled = false;
    if(seedConfirmModalEl && window.bootstrap){
      const inst = bootstrap.Modal.getInstance(seedConfirmModalEl);
      inst?.hide();
    }
    if(seedConfirmFallbackEl) seedConfirmFallbackEl.classList.remove('show');
  }
}
if(seedSampleBtn){
  seedSampleBtn.addEventListener("click", ()=>{
    if(seedSampleInFlight) return;
    if(seedConfirmModalEl && window.bootstrap){
      const modal = bootstrap.Modal.getOrCreateInstance(seedConfirmModalEl);
      modal.show();
    } else if(seedConfirmFallbackEl){
      seedConfirmFallbackEl.classList.add('show');
    } else {
      performSeedSample();
    }
  });
}
if(seedConfirmConfirm){
  seedConfirmConfirm.addEventListener("click", ()=> performSeedSample());
}
if(seedConfirmCancel && seedConfirmModalEl){
  seedConfirmCancel.addEventListener("click", ()=>{
    const inst = bootstrap.Modal.getInstance(seedConfirmModalEl);
    inst?.hide();
    setStatus("localImportStatus", "Sample data seeding cancelled.", "info");
    setStatus("seedSampleStatus", "Sample data seeding cancelled.", "info");
  });
}
if(seedConfirmFallbackConfirm){
  seedConfirmFallbackConfirm.addEventListener("click", ()=> performSeedSample());
}
if(seedConfirmFallbackCancel && seedConfirmFallbackEl){
  seedConfirmFallbackCancel.addEventListener("click", ()=>{
    seedConfirmFallbackEl.classList.remove('show');
    setStatus("localImportStatus", "Sample data seeding cancelled.", "info");
    setStatus("seedSampleStatus", "Sample data seeding cancelled.", "info");
  });
}
if(seedConfirmFallbackEl){
  seedConfirmFallbackEl.addEventListener("click", ev => {
    if(ev.target === seedConfirmFallbackEl){
      seedConfirmFallbackEl.classList.remove('show');
      setStatus("localImportStatus", "Sample data seeding cancelled.", "info");
      setStatus("seedSampleStatus", "Sample data seeding cancelled.", "info");
    }
  });
}

// ======= Barcode scanner =======
const openScannerBtn = document.getElementById('openScanner');
const scanModalEl = document.getElementById('scanModal');
const scanVideo = document.getElementById('scanVideo');
const scanMatchPanel = document.getElementById('scanMatchPanel');
const scanDetected = document.getElementById('scanDetected');
const scanMatchInfo = document.getElementById('scanMatchInfo');
const scanConfirmBtn = document.getElementById('scanConfirm');
const scanIgnoreBtn = document.getElementById('scanIgnore');
const scanEditBtn = document.getElementById('scanEdit');
const scanAddBtn = document.getElementById('scanAdd');
const scanStopBtn = document.getElementById('scanStop');
const manualScanInput = document.getElementById('manualScanInput');
const manualScanSubmit = document.getElementById('manualScanSubmit');
const scanFlipBtn = document.getElementById('scanFlip');
const scanZoomSlider = document.getElementById('scanZoomSlider');
const scanZoomStatus = document.getElementById('scanZoomStatus');
const scanFallbackEl = document.getElementById('scanFallback');
const scanVideoFallback = document.getElementById('scanVideoFallback');
const scanMatchPanelFallback = document.getElementById('scanMatchPanelFallback');
const scanDetectedFallback = document.getElementById('scanDetectedFallback');
const scanMatchInfoFallback = document.getElementById('scanMatchInfoFallback');
const scanConfirmFallbackBtn = document.getElementById('scanConfirmFallback');
const scanIgnoreFallbackBtn = document.getElementById('scanIgnoreFallback');
const scanEditFallbackBtn = document.getElementById('scanEditFallback');
const scanAddFallbackBtn = document.getElementById('scanAddFallback');
const scanStopFallbackBtn = document.getElementById('scanStopFallback');
const scanCloseFallbackBtn = document.getElementById('scanCloseFallback');
const manualScanInputFallback = document.getElementById('manualScanInputFallback');
const manualScanSubmitFallback = document.getElementById('manualScanSubmitFallback');
const scanFlipFallbackBtn = document.getElementById('scanFlipFallback');
const scanZoomSliderFallback = document.getElementById('scanZoomSliderFallback');
const scanZoomStatusFallback = document.getElementById('scanZoomStatusFallback');
const scanOverlayEl = document.getElementById('scanOverlay');
const scanOverlayFallbackEl = document.getElementById('scanOverlayFallback');
const scanOverlayToggle = document.getElementById('scanOverlayToggle');
const scanOverlayToggleFallback = document.getElementById('scanOverlayToggleFallback');

const SCAN_OVERLAY_MODES = ["none","qr","barcode"];
const scanOverlayLabels = {
  none: "Overlay: None",
  qr: "Overlay: QR",
  barcode: "Overlay: Barcode"
};
let scanOverlayIndex = 0;

function setScanOverlayMode(mode){
  if(!SCAN_OVERLAY_MODES.includes(mode)){
    mode = "none";
  }
  scanOverlayIndex = SCAN_OVERLAY_MODES.indexOf(mode);
  const attr = mode === "none" ? null : mode;
  [scanOverlayEl, scanOverlayFallbackEl].forEach(el=>{
    if(!el) return;
    if(attr){
      el.setAttribute("data-mode", attr);
    } else {
      el.removeAttribute("data-mode");
    }
  });
  const label = scanOverlayLabels[mode] || scanOverlayLabels.none;
  [scanOverlayToggle, scanOverlayToggleFallback].forEach(btn=>{
    if(!btn) return;
    btn.textContent = label;
    btn.setAttribute("data-mode", mode);
    btn.setAttribute("aria-pressed", mode === "none" ? "false" : "true");
  });
}

function cycleScanOverlayMode(){
  const nextIdx = (scanOverlayIndex + 1) % SCAN_OVERLAY_MODES.length;
  setScanOverlayMode(SCAN_OVERLAY_MODES[nextIdx]);
}

setScanOverlayMode("none");
applyFacingModeStyling();

const scanContexts = {
  modal: {
    statusId: "scanStatus",
    manualStatusId: "manualScanStatus",
    video: scanVideo,
    matchPanel: scanMatchPanel,
    detected: scanDetected,
    matchInfo: scanMatchInfo,
    confirm: scanConfirmBtn,
    ignore: scanIgnoreBtn,
    edit: scanEditBtn,
    add: scanAddBtn,
    stop: scanStopBtn,
    manualInput: manualScanInput,
    manualSubmit: manualScanSubmit,
    root: scanModalEl
  },
  fallback: {
    statusId: "scanStatusFallback",
    manualStatusId: "manualScanStatusFallback",
    video: scanVideoFallback,
    matchPanel: scanMatchPanelFallback,
    detected: scanDetectedFallback,
    matchInfo: scanMatchInfoFallback,
    confirm: scanConfirmFallbackBtn,
    ignore: scanIgnoreFallbackBtn,
    edit: scanEditFallbackBtn,
    add: scanAddFallbackBtn,
    stop: scanStopFallbackBtn,
    manualInput: manualScanInputFallback,
    manualSubmit: manualScanSubmitFallback,
    root: scanFallbackEl
  }
};
let scanCtx = null;
let scanStream = null;
let scanDetector = null;
let scanActive = false;
let scanPaused = false;
let scanLoopTimer = null;
let currentScanRow = null;
let currentScanCode = "";
let zxingReader = null;
let zxingActive = false;
let pendingPayloads = [];
let qrCanvas = null;
let qrCtx = null;
let qrRotateCanvas = null;
let qrRotateCtx = null;
const ignoredCodes = new Set();
let lastScanContext = null;
let ocrCanvas = null;
let ocrCtx = null;
let activeFacingMode = 'environment';
let activeZoomLevel = 0;
let cameraCapabilities = {};
let activeVideoTrack = null;
let scanStartTimer = null;
let zoomRange = null;
const FRONT_ZOOM_LIMIT = 0.4;
async function configureCameraTrack(track){
  if(!track) return;
  const caps = track.getCapabilities ? track.getCapabilities() : {};
  const settings = track.getSettings ? track.getSettings() : {};
  const constraints = { advanced: [] };
  cameraCapabilities = caps || {};
  activeVideoTrack = track;
  if(caps.zoom){
    const rawMin = Number.isFinite(caps.zoom.min) ? caps.zoom.min : 1;
    const rawMax = Number.isFinite(caps.zoom.max) ? caps.zoom.max : rawMin;
    const span = rawMax - rawMin;
    const effectiveMax = activeFacingMode === 'user' && span > 0
      ? rawMin + span * FRONT_ZOOM_LIMIT
      : rawMax;
    zoomRange = { min: rawMin, max: effectiveMax, physicalMax: rawMax };
    const normalized = Number.isFinite(activeZoomLevel) ? activeZoomLevel : 0;
    const targetZoom = rawMin + (effectiveMax - rawMin) * Math.min(1, Math.max(0, normalized));
    constraints.advanced.push({ zoom: targetZoom });
  } else {
    zoomRange = null;
  }
  if(caps.focusMode && caps.focusMode.includes('continuous')){
    constraints.advanced.push({ focusMode: 'continuous' });
  }
  if(caps.torch && !settings.torch && activeFacingMode === 'environment'){
    constraints.advanced.push({ torch: true });
  }
  if(constraints.advanced.length){
    try {
      await track.applyConstraints(constraints);
    } catch(err){
      console.warn('Camera constraint apply failed', err);
    }
  }
  if(caps.zoom){
    const min = zoomRange?.min ?? (Number.isFinite(caps.zoom.min) ? caps.zoom.min : 1);
    const effectiveMax = zoomRange?.max ?? (Number.isFinite(caps.zoom.max) ? caps.zoom.max : min);
    const currentSetting = track.getSettings?.().zoom ?? settings.zoom ?? min;
    const clamped = Math.min(currentSetting, effectiveMax);
    activeZoomLevel = effectiveMax !== min ? (clamped - min) / (effectiveMax - min) : 0;
  } else {
    activeZoomLevel = 0;
  }
  updateZoomStatus();
  applyFacingModeStyling();
}
function applyFacingModeStyling(){
  const isFront = activeFacingMode === 'user';
  [scanVideo, scanVideoFallback].forEach(video => {
    if(!video) return;
    video.classList.toggle('front-facing', isFront);
    const frame = video.closest('.scan-frame');
    if(frame){
      frame.classList.toggle('front-facing', isFront);
    }
  });
}
function ensureQrCanvas(width, height){
  if(!qrCanvas){
    qrCanvas = document.createElement('canvas');
    qrCtx = qrCanvas.getContext('2d', { willReadFrequently: true }) || qrCanvas.getContext('2d');
  }
  const w = Math.max(1, Math.floor(width));
  const h = Math.max(1, Math.floor(height));
  if(qrCanvas.width !== w || qrCanvas.height !== h){
    qrCanvas.width = w;
    qrCanvas.height = h;
  }
  return qrCtx;
}
function updateZoomStatus(){
  if(!scanZoomStatus && !scanZoomStatusFallback) return;
  const caps = cameraCapabilities || {};
  if(!caps.zoom){
    if(scanZoomStatus) scanZoomStatus.textContent = '';
    if(scanZoomStatusFallback) scanZoomStatusFallback.textContent = '';
    if(scanZoomSlider){
      scanZoomSlider.value = 0;
      scanZoomSlider.max = 100;
      scanZoomSlider.dataset.facing = activeFacingMode;
    }
    if(scanZoomSliderFallback){
      scanZoomSliderFallback.value = 0;
      scanZoomSliderFallback.max = 100;
      scanZoomSliderFallback.dataset.facing = activeFacingMode;
    }
    return;
  }
  const min = zoomRange?.min ?? (Number.isFinite(caps.zoom.min) ? caps.zoom.min : 1);
  const limit = zoomRange?.max ?? (Number.isFinite(caps.zoom.max) ? caps.zoom.max : min);
  const rawSetting = activeVideoTrack?.getSettings?.().zoom;
  const currentSetting = Number.isFinite(rawSetting)
    ? rawSetting
    : (min + (limit - min) * activeZoomLevel);
  if(!Number.isFinite(currentSetting)){
    if(scanZoomStatus) scanZoomStatus.textContent = '';
    if(scanZoomStatusFallback) scanZoomStatusFallback.textContent = '';
    if(scanZoomSlider) scanZoomSlider.value = 0;
    if(scanZoomSliderFallback) scanZoomSliderFallback.value = 0;
    return;
  }
  const clamped = Math.min(currentSetting, limit);
  const percent = limit !== min ? Math.round(((clamped - min) / (limit - min)) * 100) : 0;
  const labelSuffix = (zoomRange && zoomRange.physicalMax && zoomRange.max < zoomRange.physicalMax - 0.001 && activeFacingMode === 'user')
    ? ' (front camera)'
    : '';
  const label = `Zoom ${currentSetting.toFixed(2)}× (${percent}%)${labelSuffix}`;
  const physicalMax = zoomRange?.physicalMax ?? limit;
  const spanPhysical = physicalMax - min;
  const sliderMax = (zoomRange && zoomRange.physicalMax && zoomRange.max < zoomRange.physicalMax - 0.001 && spanPhysical > 0)
    ? Math.max(10, Math.round(((limit - min) / spanPhysical) * 100))
    : 100;
  const sliderValue = Math.min(sliderMax, Math.round((percent / 100) * sliderMax));
  if(scanZoomStatus) scanZoomStatus.textContent = label;
  if(scanZoomStatusFallback) scanZoomStatusFallback.textContent = label;
  if(scanZoomSlider){
    scanZoomSlider.max = sliderMax;
    scanZoomSlider.value = sliderValue;
    scanZoomSlider.dataset.facing = activeFacingMode;
  }
  if(scanZoomSliderFallback){
    scanZoomSliderFallback.max = sliderMax;
    scanZoomSliderFallback.value = sliderValue;
    scanZoomSliderFallback.dataset.facing = activeFacingMode;
  }
}
async function adjustZoom(delta){
  if(!activeVideoTrack || !(cameraCapabilities?.zoom)) return;
  if(Number.isFinite(delta)){
    activeZoomLevel = Math.min(1, Math.max(0, activeZoomLevel + delta));
  }
  const min = zoomRange?.min ?? (Number.isFinite(cameraCapabilities.zoom.min) ? cameraCapabilities.zoom.min : 1);
  const limit = zoomRange?.max ?? (Number.isFinite(cameraCapabilities.zoom.max) ? cameraCapabilities.zoom.max : min);
  const target = min + (limit - min) * activeZoomLevel;
  try {
    await activeVideoTrack.applyConstraints({ advanced: [{ zoom: target }] });
  } catch(err){
    console.warn('Zoom adjust failed', err);
  }
  updateZoomStatus();
}
async function toggleCamera(){
  activeFacingMode = activeFacingMode === 'environment' ? 'user' : 'environment';
  activeZoomLevel = 0;
  updateZoomStatus();
  applyFacingModeStyling();
  stopScanner();
  if(scanCtx){
    startScanner(scanCtx === scanContexts.fallback);
  } else if(lastScanContext){
    startScanner(lastScanContext === scanContexts.fallback);
  } else {
    startScanner(false);
  }
}
function detectQrFromFrame(video){
  if(!video || !window.jsQR) return null;
  const width = video.videoWidth || video.clientWidth;
  const height = video.videoHeight || video.clientHeight;
  if(!width || !height) return null;
  const attemptDecode = (canvasCtx, w, h)=>{
    const data = canvasCtx.getImageData(0, 0, w, h);
    const res = window.jsQR(data.data, w, h, { inversionAttempts: 'attemptBoth' });
    return res && res.data ? res.data : null;
  };
  const ensureRotateCanvas = (w, h)=>{
    if(!qrRotateCanvas){
      qrRotateCanvas = document.createElement('canvas');
      qrRotateCtx = qrRotateCanvas.getContext('2d', { willReadFrequently: true }) || qrRotateCanvas.getContext('2d');
    }
    if(qrRotateCanvas.width !== w || qrRotateCanvas.height !== h){
      qrRotateCanvas.width = w;
      qrRotateCanvas.height = h;
    }
    qrRotateCtx.setTransform(1,0,0,1,0,0);
    qrRotateCtx.clearRect(0,0,w,h);
    return qrRotateCtx;
  };
  const attempts = [
    { sx:0, sy:0, w:width, h:height },
    { sx:Math.max(0, Math.floor(width*0.1)), sy:Math.max(0, Math.floor(height*0.1)), w:Math.floor(width*0.8), h:Math.floor(height*0.8) },
    { sx:Math.max(0, Math.floor(width*0.2)), sy:Math.max(0, Math.floor(height*0.2)), w:Math.floor(width*0.6), h:Math.floor(height*0.6) }
  ];
  try {
    for(const attempt of attempts){
      const { sx, sy, w, h } = attempt;
      const ctx = ensureQrCanvas(w, h);
      ctx.drawImage(video, sx, sy, w, h, 0, 0, w, h);
      let payload = attemptDecode(ctx, w, h);
      if(payload) return payload;
      const rotations = [Math.PI / 2, Math.PI, 1.5 * Math.PI];
      for(const angle of rotations){
        const rotateWidth = (angle === Math.PI / 2 || angle === 1.5 * Math.PI) ? h : w;
        const rotateHeight = (angle === Math.PI / 2 || angle === 1.5 * Math.PI) ? w : h;
        const rCtx = ensureRotateCanvas(rotateWidth, rotateHeight);
        rCtx.save();
        rCtx.translate(rotateWidth / 2, rotateHeight / 2);
        rCtx.rotate(angle);
        rCtx.drawImage(qrCanvas, -w / 2, -h / 2);
        rCtx.restore();
        payload = attemptDecode(rCtx, rotateWidth, rotateHeight);
        if(payload) return payload;
      }
    }
  } catch(err){
    console.warn('jsQR detection failed', err);
  }
  return null;
}

function getScanCtx(useFallback){ return useFallback ? scanContexts.fallback : scanContexts.modal; }
function setScanStatusMessage(message, variant="info"){
  if(!scanCtx || !scanCtx.statusId) return;
  setStatus(scanCtx.statusId, message, variant);
}
function setManualStatusMessage(message, variant="info"){
  if(!scanCtx || !scanCtx.manualStatusId) return;
  if(message === ""){
    const el = document.getElementById(scanCtx.manualStatusId);
    if(el) el.textContent = "";
    return;
  }
  setStatus(scanCtx.manualStatusId, message, variant);
}
function hideScanMatchPanel(){
  if(!scanCtx) return;
  if(scanCtx.matchPanel){
    scanCtx.matchPanel.classList.add('d-none');
  }
  if(scanCtx.confirm){
    scanCtx.confirm.disabled = true;
  }
  if(scanCtx.edit){
    scanCtx.edit.classList.add('d-none');
  }
  if(scanCtx.add){
    scanCtx.add.classList.add('d-none');
  }
  if(scanCtx.stop){
    scanCtx.stop.textContent = "Stop scanning";
    scanCtx.stop.disabled = false;
  }
  currentScanRow = null;
  currentScanCode = "";
}
function extractBarcodeValue(results){
  if(!Array.isArray(results)) return "";
  for(const entry of results){
    if(!entry) continue;
    if(entry.rawValue) return String(entry.rawValue);
    if(entry.data) return String(entry.data);
  }
  return "";
}
function extractSerialFromPayload(payload){
  if(!payload) return null;
  let text = payload;
  try {
    if(/^mailto:/i.test(payload)){ text = payload.split(':').slice(1).join(':'); }
    if(/^https?:/i.test(payload)){
      const url = new URL(payload);
      if(url.searchParams.size){
        for(const value of url.searchParams.values()){
          const candidate = extractSerialCandidates(value).map(normalizeSerialCandidate).find(Boolean);
          if(candidate) return candidate;
        }
      }
      text = [url.pathname, url.hash].filter(Boolean).join(' ');
    } else if(/^[A-F0-9+\/=]+$/i.test(payload) && payload.length % 4 === 0){
      const decoded = atob(payload);
      if(decoded) text = decoded;
    }
  } catch{}
  const candidates = extractSerialCandidates(text);
  if(!candidates.length) return null;
  return normalizeSerialCandidate(candidates[0]);
}
function extractSerialCandidates(text){
  if(!text) return [];
  const uppercase = text.toUpperCase();
  const matches = uppercase.match(/\b[A-Z0-9]{7}\b/g);
  if(!matches) return [];
  // Dell serials usually omit I/O/Q; filter obvious noise (all digits or repeated chars)
  return matches.filter(code => {
    const uniqueChars = new Set(code.split(""));
    return uniqueChars.size >= 3;
  });
}
function normalizeSerialCandidate(code){
  if(!code) return "";
  let value = code.toUpperCase();
  const replacements = {
    '0': 'O',
    '1': 'I',
    '5': 'S',
    '6': 'G',
    '8': 'B',
    '9': 'G',
    'O': 'O',
    'I': 'I',
    'Z': 'Z'
  };
  const chars = value.split("");
  for(let i=0;i<chars.length;i++){
    const ch = chars[i];
    if(/[0-9]/.test(ch)){
      const repl = replacements[ch];
      if(repl && /[A-Z]/.test(chars[i-1] || '') && /[A-Z]/.test(chars[i+1] || '')){
        chars[i] = repl;
      }
    }
  }
  value = chars.join("");
  const match = value.match(/^[A-Z0-9]{7}$/);
  return match ? value : code.toUpperCase();
}
function ensureOcrCanvas(width, height){
  if(!ocrCanvas){
    ocrCanvas = document.createElement('canvas');
    ocrCtx = ocrCanvas.getContext('2d', { willReadFrequently: true }) || ocrCanvas.getContext('2d');
  }
  const minWidth = 320;
  const minHeight = 200;
  const w = Math.max(minWidth, Math.floor(width));
  const h = Math.max(minHeight, Math.floor(height));
  if(ocrCanvas.width !== w || ocrCanvas.height !== h){
    ocrCanvas.width = w;
    ocrCanvas.height = h;
  }
  return ocrCtx;
}
function scheduleScanLoop(delay=300){
  clearTimeout(scanLoopTimer);
  if(zxingActive) return;
  if(!scanActive || scanPaused || !scanCtx || !scanCtx.video) return;
  scanLoopTimer = setTimeout(async ()=>{
    if(pendingPayloads.length){
      const payload = pendingPayloads.shift();
      const normalized = extractSerialFromPayload(payload);
      const candidate = normalized || payload.trim();
      if(candidate){
        presentScanMatch(candidate);
        scheduleScanLoop(900);
        return;
      }
    }

    if(scanCtx?.video){
      const qrPayload = detectQrFromFrame(scanCtx.video);
      if(qrPayload){
        const normalizedQr = extractSerialFromPayload(qrPayload);
        const candidateQr = normalizedQr || qrPayload.trim();
        if(candidateQr){
          presentScanMatch(candidateQr);
          scheduleScanLoop(900);
          return;
        }
        pendingPayloads.push(qrPayload);
      }
    }

    if(!scanActive || !scanCtx || !scanCtx.video){
      return;
    }
    if(scanPaused){
      scheduleScanLoop(250);
      return;
    }
    if(scanDetector){
      try {
        const results = await scanDetector.detect(scanCtx.video);
        const value = extractBarcodeValue(results);
        if(value){
          const normalized = extractSerialFromPayload(value);
          const candidate = normalized || value.trim();
          if(candidate){
            presentScanMatch(candidate);
            scheduleScanLoop(900);
            return;
          }
          pendingPayloads.push(value.trim());
        }
      } catch(err){
        console.warn("Barcode detection failed", err);
        setScanStatusMessage(`Scanning error: ${err.message}`, "error");
      }
    }
    scheduleScanLoop(200);
  }, delay);
}
function startOcrLoop(){
  // OCR disabled
}
function stopOcrLoop(){
  // no-op
}
function presentScanMatch(code){
  if(!scanCtx) return;
  const normalized = normalizeSerialCandidate(code.trim());
  if(!normalized){
    scheduleScanLoop(200);
    return;
  }
  const lower = normalized.toLowerCase();
  if(ignoredCodes.has(lower)){
    setScanStatusMessage(`Ignored ${normalized}. Continuing scan.`, "info");
    scanPaused = false;
    scheduleScanLoop(250);
    return;
  }
  currentScanCode = normalized;
  currentScanRow = findRowBySerial(normalized);
  if(scanCtx.matchPanel){
    scanCtx.matchPanel.classList.remove('d-none');
  }
  if(scanCtx.detected){
    scanCtx.detected.textContent = `Serial: ${normalized}`;
  }
  if(currentScanRow){
    const obj = rowToObj(currentScanRow);
    const idText = obj.id ? `Asset ${obj.id}` : "Matched asset";
    const detail = obj.model ? `${obj.model}` : (obj.type || "");
    const location = obj.assigned_to ? `Assigned to ${obj.assigned_to}` : "";
    const infoParts = [idText, detail, location].filter(Boolean);
    if(scanCtx.matchInfo){
      scanCtx.matchInfo.textContent = infoParts.join(" • ") || "Matched asset.";
    }
    if(scanCtx.confirm){
      scanCtx.confirm.disabled = false;
    }
    if(scanCtx.edit){
      scanCtx.edit.classList.remove('d-none');
      scanCtx.edit.disabled = false;
    }
    if(scanCtx.add){
      scanCtx.add.classList.add('d-none');
    }
    setScanStatusMessage("Match found. Confirm, edit, or ignore.", "success");
    setManualStatusMessage("", "info");
  } else {
    if(scanCtx.matchInfo){
      scanCtx.matchInfo.textContent = "No asset matches this serial number. Use manual lookup or add new asset.";
    }
    if(scanCtx.confirm){
      scanCtx.confirm.disabled = true;
    }
    if(scanCtx.edit){
      scanCtx.edit.classList.add('d-none');
    }
    if(scanCtx.add){
      scanCtx.add.classList.remove('d-none');
      scanCtx.add.disabled = false;
    }
    setScanStatusMessage("No matching asset found. Add new asset or ignore.", "error");
    setManualStatusMessage("", "info");
  }
  scanPaused = true;
}
async function startScanner(useFallback){
  if(scanStartTimer){
    clearTimeout(scanStartTimer);
    scanStartTimer = null;
  }
  stopScanner();
  scanCtx = getScanCtx(useFallback);
  lastScanContext = scanCtx;
  if(!scanCtx){
    setStatus("localImportStatus", "Scanner UI unavailable on this device.", "error");
    return;
  }
  hideScanMatchPanel();
  setManualStatusMessage("", "info");
  if(scanCtx.video){
    scanCtx.video.srcObject = null;
  }
  if(!("mediaDevices" in navigator) || !navigator.mediaDevices.getUserMedia){
    setScanStatusMessage("Camera access is not supported on this device. Use manual lookup.", "error");
    if(scanCtx.stop){
      scanCtx.stop.textContent = "Start scanning";
      scanCtx.stop.disabled = false;
    }
    scanActive = false;
    scanPaused = true;
    return;
  }
  if(scanCtx.stop){
    scanCtx.stop.disabled = true;
    scanCtx.stop.textContent = "Starting…";
  }
  try {
    setScanStatusMessage("Requesting camera…", "info");
    const constraints = {
      video: {
        facingMode: { ideal: activeFacingMode },
        width: { ideal: 1280 },
        height: { ideal: 720 },
        zoom: { ideal: activeFacingMode === 'environment' ? 2 : 1 }
      },
      audio: false
    };
    try {
      scanStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch(err){
      console.warn('Primary camera constraints failed, retrying with defaults', err);
      scanStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: activeFacingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
    }
    const videoTrack = scanStream.getVideoTracks()[0];
    if(videoTrack){
      await configureCameraTrack(videoTrack);
      const facing = videoTrack.getSettings?.().facingMode;
      if(typeof facing === "string" && facing.trim()){
        const normalizedFacing = facing.toLowerCase();
        if(normalizedFacing.includes("user") || normalizedFacing.includes("front") || normalizedFacing.includes("face")){
          activeFacingMode = "user";
        } else if(normalizedFacing.includes("environment") || normalizedFacing.includes("back") || normalizedFacing.includes("rear") || normalizedFacing.includes("world")){
          activeFacingMode = "environment";
        } else {
          activeFacingMode = normalizedFacing;
        }
      }
      applyFacingModeStyling();
    }
    if(scanCtx.video){
      scanCtx.video.srcObject = scanStream;
      await scanCtx.video.play().catch(()=>{});
    }
    scanActive = true;
    scanPaused = false;
    if(scanCtx.stop){
      scanCtx.stop.textContent = "Stop scanning";
      scanCtx.stop.disabled = false;
    }
    setScanStatusMessage("Camera ready. Hold the barcode steady in view.", "info");
    if('BarcodeDetector' in window){
      if(!scanDetector){
        try {
          scanDetector = new window.BarcodeDetector({ formats: ["code_128","code_39","ean_13","ean_8","upc_a","upc_e","qr_code"] });
        } catch(err){
          console.warn("BarcodeDetector init failed", err);
          scanDetector = null;
        }
      }
      if(scanDetector){
        setScanStatusMessage("Point the camera at a barcode. Hold steady to detect.", "info");
        scheduleScanLoop(350);
      }
    }
    if(!scanDetector){
      setScanStatusMessage("Barcode detector unavailable. Using ZXing fallback.", "info");
      scheduleScanLoop(350);
    }
    startZXingLoop();
  } catch(err){
    console.error("Camera initialization failed", err);
    setScanStatusMessage(`Unable to access camera: ${err.message}`, "error");
    scanActive = false;
    scanPaused = true;
    if(scanCtx?.stop){
      scanCtx.stop.textContent = "Start scanning";
      scanCtx.stop.disabled = false;
    }
    if(scanStream){
      scanStream.getTracks().forEach(track => track.stop());
      scanStream = null;
    }
  }
}
function stopScanner(){
  const ctx = scanCtx || lastScanContext;
  clearTimeout(scanLoopTimer);
  scanLoopTimer = null;
  if(scanStartTimer){
    clearTimeout(scanStartTimer);
    scanStartTimer = null;
  }
  scanActive = false;
  scanPaused = false;
  stopOcrLoop();
  if(scanStream){
    scanStream.getTracks().forEach(track => track.stop());
    scanStream = null;
  }
  activeVideoTrack = null;
  cameraCapabilities = {};
  zoomRange = null;
  if(zxingReader){
    try { zxingReader.reset(); } catch {}
  }
  zxingActive = false;
  const videoEl = scanCtx?.video || ctx?.video;
  if(videoEl){
    videoEl.srcObject = null;
  }
  hideScanMatchPanel();
  if(ctx?.stop){
    ctx.stop.textContent = "Start scanning";
    ctx.stop.disabled = false;
  }
  lastScanContext = ctx;
  pendingPayloads.length = 0;
  scanCtx = null;
  updateZoomStatus();
}
function startZXingLoop(){
  if(!scanCtx || !scanCtx.video){
    setScanStatusMessage("Scanner unavailable. Use manual lookup.", "error");
    return;
  }
  if(!window.ZXing || !window.ZXing.BrowserMultiFormatReader){
    setScanStatusMessage("ZXing library not available. Use manual lookup.", "error");
    return;
  }
  try {
    if(zxingReader){
      zxingReader.reset();
    } else {
      zxingReader = new window.ZXing.BrowserMultiFormatReader();
    }
    zxingReader.decodeFromVideoElement(scanCtx.video, (result, err)=>{
      if(!scanActive || scanPaused){
        return;
      }
      if(result){
        const payload = result.getText?.() || result.text || "";
        if(payload){
          const normalized = extractSerialFromPayload(payload);
          const candidate = normalized || (payload || '').trim();
          if(candidate){
            presentScanMatch(candidate);
          }
        }
      } else if(err && !(err instanceof window.ZXing.NotFoundException)){
        console.warn("ZXing decode error", err);
      }
    });
    zxingActive = true;
    setScanStatusMessage("Point the camera at a barcode. Hold steady to detect.", "info");
  } catch(err){
    console.error("ZXing initialization failed", err);
    setScanStatusMessage(`ZXing fallback failed: ${err.message}`, "error");
  }
}
async function handleScanConfirm(){
  if(!currentScanRow){
    setManualStatusMessage("No matching asset to update.", "error");
    return;
  }
  try {
    await markRowVerified(currentScanRow);
    updateMetaButtonState(currentScanRow);
    updateNoteButtonState(currentScanRow);
    const obj = rowToObj(currentScanRow);
    const assetLabel = obj.id ? `Asset ${obj.id}` : (obj.serial_number ? `Serial ${obj.serial_number}` : "Asset");
    const successMsg = `${assetLabel} verified.`;
    setScanStatusMessage(successMsg, "success");
    showSavedToast(successMsg, "localImportStatus");
    hideScanMatchPanel();
    scanPaused = false;
    scheduleScanLoop(400);
  } catch(err){
    console.error("Failed to mark asset verified", err);
    setScanStatusMessage(`Failed to update asset: ${err.message}`, "error");
  }
}
function handleScanIgnore(){
  if(currentScanCode){
    ignoredCodes.add(currentScanCode.toLowerCase());
  }
  hideScanMatchPanel();
  setScanStatusMessage("Barcode ignored. Continue scanning.", "info");
  setManualStatusMessage("", "info");
  scanPaused = false;
  scheduleScanLoop(300);
}
async function handleScanToggle(useFallback){
  const ctx = getScanCtx(useFallback);
  if(!ctx) return;
  if(scanActive || zxingActive){
    if(ctx.statusId) setStatus(ctx.statusId, "Scanning stopped. Use manual lookup or start scanning.", "info");
    if(ctx.manualStatusId) setStatus(ctx.manualStatusId, "", "info");
    stopScanner();
  } else {
    if(ctx.statusId) setStatus(ctx.statusId, "Requesting camera…", "info");
    if(ctx.manualStatusId) setStatus(ctx.manualStatusId, "", "info");
    await startScanner(useFallback);
  }
}
function closeScannerUI(){
  stopScanner();
  if(scanModalEl && window.bootstrap){
    const scanModalInstance = bootstrap.Modal.getInstance(scanModalEl);
    scanModalInstance?.hide();
  }
  if(scanFallbackEl){
    scanFallbackEl.classList.remove('show');
  }
}
function handleScanEdit(){
  if(!currentScanRow) return;
  const targetRow = currentScanRow;
  closeScannerUI();
  setStatus("localImportStatus", "Opening asset in edit mode.", "info");
  openViewAsset(targetRow, { edit: true });
}
function handleScanAdd(){
  if(!currentScanCode) return;
  const serialValue = currentScanCode;
  closeScannerUI();
  setStatus("localImportStatus", "Preparing new asset entry.", "info");
  showAddModal({ serial_number: serialValue, focus: "serial" });
}
function handleManualLookup(inputValue){
  const value = (inputValue ?? "").toString().trim();
  if(!value){
    setManualStatusMessage("Enter a serial number to search.", "info");
    return;
  }
  hideScanMatchPanel();
  presentScanMatch(value);
  if(currentScanRow){
    setManualStatusMessage("Match found. Confirm to record verification or open in edit.", "success");
  } else if(currentScanCode && currentScanCode.toLowerCase() === value.toLowerCase()){
    setManualStatusMessage(`No asset found for serial "${value}".`, "error");
  }
}

if(openScannerBtn){
  openScannerBtn.addEventListener("click", ()=>{
    if(scanModalEl && window.bootstrap){
      const modal = bootstrap.Modal.getOrCreateInstance(scanModalEl);
      modal.show();
      if(scanStartTimer){
        clearTimeout(scanStartTimer);
      }
      scanStartTimer = setTimeout(()=>{
        scanStartTimer = null;
        startScanner(false);
      }, 120);
    } else if(scanFallbackEl){
      scanFallbackEl.classList.add('show');
      startScanner(true);
    } else {
      setStatus("localImportStatus", "Scanner unsupported on this device.", "error");
    }
  });
}
if(scanModalEl){
  const modalHandler = ()=> stopScanner();
  if(window.bootstrap){
    scanModalEl.addEventListener("hide.bs.modal", modalHandler);
    scanModalEl.addEventListener("hidden.bs.modal", modalHandler);
  }
  scanModalEl.addEventListener("click", ev => {
    if(ev.target?.closest('[data-bs-dismiss="modal"]')){
      stopScanner();
    }
  });
}
if(scanFallbackEl){
  scanFallbackEl.addEventListener("click", ev => {
    if(ev.target === scanFallbackEl){
      stopScanner();
      scanFallbackEl.classList.remove('show');
    }
  });
}
if(scanConfirmBtn){
  scanConfirmBtn.addEventListener("click", ()=> handleScanConfirm());
}
if(scanConfirmFallbackBtn){
  scanConfirmFallbackBtn.addEventListener("click", ()=> handleScanConfirm());
}
if(scanEditBtn){
  scanEditBtn.addEventListener("click", ()=> handleScanEdit());
}
if(scanEditFallbackBtn){
  scanEditFallbackBtn.addEventListener("click", ()=> handleScanEdit());
}
if(scanAddBtn){
  scanAddBtn.addEventListener("click", ()=> handleScanAdd());
}
if(scanAddFallbackBtn){
  scanAddFallbackBtn.addEventListener("click", ()=> handleScanAdd());
}
if(scanIgnoreBtn){
  scanIgnoreBtn.addEventListener("click", ()=> handleScanIgnore());
}
if(scanIgnoreFallbackBtn){
  scanIgnoreFallbackBtn.addEventListener("click", ()=> handleScanIgnore());
}
if(scanStopBtn){
  scanStopBtn.addEventListener("click", ()=> handleScanToggle(false));
}
if(scanStopFallbackBtn){
  scanStopFallbackBtn.addEventListener("click", ()=> handleScanToggle(true));
}
if(scanZoomSlider){
  scanZoomSlider.addEventListener("input", e => {
    const max = Number(e.target.max) || 100;
    const value = Number(e.target.value) / max;
    if(!Number.isFinite(value)) return;
    activeZoomLevel = Math.min(1, Math.max(0, value));
    adjustZoom();
  });
}
if(scanZoomSliderFallback){
  scanZoomSliderFallback.addEventListener("input", e => {
    const max = Number(e.target.max) || 100;
    const value = Number(e.target.value) / max;
    if(!Number.isFinite(value)) return;
    activeZoomLevel = Math.min(1, Math.max(0, value));
    adjustZoom();
  });
}
if(scanOverlayToggle){
  scanOverlayToggle.addEventListener("click", ()=> cycleScanOverlayMode());
}
if(scanOverlayToggleFallback){
  scanOverlayToggleFallback.addEventListener("click", ()=> cycleScanOverlayMode());
}
if(scanFlipBtn){
  scanFlipBtn.addEventListener("click", ()=> toggleCamera());
}
if(scanFlipFallbackBtn){
  scanFlipFallbackBtn.addEventListener("click", ()=> toggleCamera());
}
updateZoomStatus();
if(scanCloseFallbackBtn){
  scanCloseFallbackBtn.addEventListener("click", ()=>{
    stopScanner();
    if(scanFallbackEl) scanFallbackEl.classList.remove('show');
  });
}
if(manualScanSubmit){
  manualScanSubmit.addEventListener("click", ()=> handleManualLookup(manualScanInput?.value));
}
if(manualScanInput){
  manualScanInput.addEventListener("keydown", ev => {
    if(ev.key === "Enter"){
      ev.preventDefault();
      handleManualLookup(manualScanInput.value);
    }
  });
}
if(manualScanSubmitFallback){
  manualScanSubmitFallback.addEventListener("click", ()=> handleManualLookup(manualScanInputFallback?.value));
}
if(manualScanInputFallback){
  manualScanInputFallback.addEventListener("keydown", ev => {
    if(ev.key === "Enter"){
      ev.preventDefault();
      handleManualLookup(manualScanInputFallback.value);
    }
  });
}
if(notesFallbackClose && notesFallbackEl){
  notesFallbackClose.addEventListener("click", ()=> notesFallbackEl.classList.remove('show'));
}
if(notesFallbackEl){
  notesFallbackEl.addEventListener("click", ev => {
    if(ev.target === notesFallbackEl){
      notesFallbackEl.classList.remove('show');
    }
  });
}
if(localSearchInput){
  const onSearchChange = debounce(value => queueTableRefresh({ search:value, resetPage:true }), 180);
  localSearchInput.addEventListener("input", e => onSearchChange(e.target.value));
}
if(localStatusFilter){
  localStatusFilter.addEventListener("change", e => queueTableRefresh({ status:e.target.value, resetPage:true }));
}
if(localPageSizeSelect){
  localPageSizeSelect.addEventListener("change", e => queueTableRefresh({ pageSize:e.target.value, resetPage:true }));
}
if(localPrevPage){
  localPrevPage.addEventListener("click", ()=>{
    queueTableRefresh({ page: tableState.page - 1 });
  });
}
if(localNextPage){
  localNextPage.addEventListener("click", ()=>{
    queueTableRefresh({ page: tableState.page + 1 });
  });
}
document.querySelectorAll('#localTable thead th[data-sort]').forEach(th => {
  th.addEventListener("click", ()=>{
    const key = th.dataset.sort;
    if(!key) return;
    let dir = "asc";
    if(tableState.sortBy === key){
      dir = tableState.sortDir === "asc" ? "desc" : "asc";
    }
    queueTableRefresh({ sortBy:key, sortDir:dir });
  });
});

async function showAddModal(defaults={}){
  const statusesList = (await idbGet(IDB_KEY_STATUS)) || [];
  populateStatusSelect(statusesList);
  const statusValue = defaults.status ?? "";
  const metaValue = typeof defaults.meta === "string"
    ? defaults.meta
    : (defaults.meta ? JSON.stringify(defaults.meta, null, 2) : "");

  const applyStatus = (selectEl, customEl)=>{
    const hasStatus = statusValue && statusesList.includes(statusValue);
    if(selectEl) selectEl.value = hasStatus ? statusValue : "";
    if(customEl) customEl.value = hasStatus ? "" : statusValue;
  };

  const applyToBootstrap = ()=>{
    if(m_serial_number) m_serial_number.value = defaults.serial_number ?? "";
    if(m_asset_tag) m_asset_tag.value = defaults.asset_tag ?? "";
    if(m_type) m_type.value = defaults.type ?? "";
    if(m_model) m_model.value = defaults.model ?? "";
    if(m_room) m_room.value = defaults.room ?? "";
    if(m_assigned_to) m_assigned_to.value = defaults.assigned_to ?? "";
    if(m_meta) m_meta.value = metaValue;
    applyStatus(m_status, m_status_custom);
  };

  const applyToFallback = ()=>{
    if(fb_serial_number) fb_serial_number.value = defaults.serial_number ?? "";
    if(fb_asset_tag) fb_asset_tag.value = defaults.asset_tag ?? "";
    if(fb_type) fb_type.value = defaults.type ?? "";
    if(fb_model) fb_model.value = defaults.model ?? "";
    if(fb_room) fb_room.value = defaults.room ?? "";
    if(fb_assigned_to) fb_assigned_to.value = defaults.assigned_to ?? "";
    if(fb_meta) fb_meta.value = metaValue;
    applyStatus(fb_status, fb_status_custom);
  };

  const focusSerial = (el)=> setTimeout(()=> el?.focus(), 150);

  if(window.bootstrap && addModalEl){
    applyToBootstrap();
    const modal = bootstrap.Modal.getOrCreateInstance(addModalEl);
    modal.show();
    focusSerial(m_serial_number || m_asset_tag);
  } else if(fbModalEl){
    applyToFallback();
    fbModalEl.classList.add('show');
    focusSerial(fb_serial_number || fb_asset_tag);
  } else {
    setStatus("localImportStatus", "Add asset UI unavailable in this environment.", "error");
  }
}

openAdd.addEventListener("click", ()=>{ showAddModal(); });
if(fb_cancel){ fb_cancel.addEventListener("click", ()=> fbModalEl.classList.remove('show')); }
if(fb_confirm){ fb_confirm.addEventListener("click", ()=>{
  const serialValue = norm(fb_serial_number?.value);
  const assetValue = norm(fb_asset_tag?.value);
  const id = serialValue || assetValue;
  if(!id){
    alert("Provide at least a serial number or asset tag.");
    (fb_serial_number || fb_asset_tag)?.focus();
    return;
  }
  const status = norm(fb_status.value) || norm(fb_status_custom.value);
  const row = {
    id,
    serial_number: serialValue,
    asset_tag: assetValue,
    type: norm(fb_type?.value),
    model: norm(fb_model?.value),
    room: norm(fb_room?.value),
    assigned_to: norm(fb_assigned_to.value),
    status,
    meta: fb_meta.value.trim()
  };
  addRow(row); fbModalEl.classList.remove('show');
}); }

if(confirmAdd){ confirmAdd.addEventListener("click", ()=>{
  const serialValue = norm(m_serial_number?.value);
  const assetValue = norm(m_asset_tag?.value);
  const id = serialValue || assetValue;
  if(!id){
    alert("Provide at least a serial number or asset tag.");
    (m_serial_number || m_asset_tag)?.focus();
    return;
  }
  const status = norm(m_status.value) || norm(m_status_custom.value);
  const row = {
    id,
    serial_number: serialValue,
    asset_tag: assetValue,
    type: norm(m_type?.value),
    model: norm(m_model?.value),
    room: norm(m_room?.value),
    assigned_to: norm(m_assigned_to.value),
    status,
    meta: m_meta.value.trim()
  };
  addRow(row); const modal = bootstrap.Modal.getInstance(addModalEl); modal?.hide();
}); }

// ======= Init (with migration) =======
(async function init(){
  // Status options
  let statuses = await idbGet(IDB_KEY_STATUS);
  if(!Array.isArray(statuses) || statuses.length===0){
    statuses = ["In Stock","Assigned","Repair","Lost","Disposed"];
    await idbSet(IDB_KEY_STATUS, statuses);
  }
  const statusInputEl = document.getElementById('statusOptions');
  if(statusInputEl) statusInputEl.value = statuses.join(", ");
  const statusSavedEl = document.getElementById('statusSaved');
  if(statusSavedEl) statusSavedEl.textContent = `Loaded ${statuses.length} item(s)`;

  // Rows
  let rows = await idbGet(IDB_KEY_ROWS);
  if(Array.isArray(rows) && rows.length){
    rows = rows.map(upgradeRow);
    await idbSet(IDB_KEY_ROWS, rows);
  } else {
    try {
      const s = localStorage.getItem(LS_KEY_MIGRATION);
      if(s){
        const parsed = JSON.parse(s);
        if(Array.isArray(parsed) && parsed.length){
          rows = parsed.map(upgradeRow).filter(r => norm(r.id));
          if(rows.length){
            await idbSet(IDB_KEY_ROWS, rows);
          }
        }
      }
    } catch {}
    if(!Array.isArray(rows)){
      rows = [];
      await idbSet(IDB_KEY_ROWS, rows);
    }
  }
  renderLocal(rows);
  updateLastSaved();
  await refreshDataStats();
})();

// ======= Inline Self-Tests (opt-in via ?selftest=1 or #selftest) =======
(function registerInlineTests(){
  try {
    const params = new URLSearchParams(window.location.search || "");
    const hash = (window.location.hash || "").toLowerCase();
    const enabled = params.has("selftest") || hash.includes("selftest");
    if(!enabled) return;

    const tests = [];
    const addTest = (name, fn) => tests.push({ name, fn });
    const assert = (condition, message) => {
      if(!condition) throw new Error(message || "Assertion failed");
    };

    addTest("normalizeFieldKey strips non-alphanumerics", ()=>{
      const result = normalizeFieldKey(" Asset-ID ");
      assert(result === "assetid", `Expected "assetid", got "${result}"`);
    });

    addTest("formatMetaForView removes reserved keys", ()=>{
      const input = JSON.stringify({ id:"A1", status:"Active", custom:"keep" });
      const output = formatMetaForView(input);
      assert(output.includes('"custom": "keep"'), "Expected custom key to remain");
      assert(!output.includes("status"), "Reserved key 'status' should be removed");
      assert(!output.includes('"id"'), "Reserved key 'id' should be removed");
    });

    addTest("formatMetaForView returns raw text when JSON parse fails", ()=>{
      const input = " not-json ";
      const output = formatMetaForView(input);
      assert(output === "not-json", "Expected raw string when parsing fails");
    });

    addTest("formatMetaForView preserves arrays", ()=>{
      const input = JSON.stringify([{ note:"Check" }]);
      const output = formatMetaForView(input);
      assert(output.trim().startsWith("["), "Expected array output");
    });
    addTest("extractSerialCandidates finds Dell format", ()=>{
      const text = "Test ABC1234 and def5678";
      const matches = extractSerialCandidates(text);
      assert(matches.includes("ABC1234"), "Expected ABC1234 present");
      assert(matches.includes("DEF5678"), "Expected DEF5678 present");
    });
    addTest("findRowBySerial handles empty values", ()=>{
      assert(findRowBySerial("") === null, "Expected null for empty serial.");
      assert(findRowBySerial(null) === null, "Expected null for null serial.");
    });
    addTest("formatBytes converts kilobytes", ()=>{
      assert(formatBytes(1024) === "1 KB", `Expected 1 KB, got ${formatBytes(1024)}`);
    });

    addTest("META_PREVIEW_LIMIT is a positive number", ()=>{
      assert(typeof META_PREVIEW_LIMIT === "number", "META_PREVIEW_LIMIT should be numeric");
      assert(Number.isFinite(META_PREVIEW_LIMIT) && META_PREVIEW_LIMIT >= 100, "META_PREVIEW_LIMIT should be >= 100");
    });

    const results = [];
    console.group("Inventory inline self-tests");
    tests.forEach(test => {
      try {
        test.fn();
        console.log(`%c✔ ${test.name}`, "color: #15803d;");
        results.push({ name: test.name, status: "passed" });
      } catch(err){
        console.error(`✖ ${test.name}`, err);
        results.push({ name: test.name, status: "failed", error: err });
      }
    });
    console.groupEnd();

    const failed = results.filter(r => r.status === "failed");
    if(failed.length){
      setStatus("localImportStatus", `${failed.length} inline test${failed.length===1?"":"s"} failed. See console for details.`, "error");
    } else if(results.length){
      setStatus("localImportStatus", `Inline tests passed (${results.length}).`, "success");
    }
  } catch(err){
    console.error("Inline test harness failed", err);
    setStatus("localImportStatus", `Inline test harness error: ${err.message}`, "error");
  }
})();
</script>
</body>
</html>
